<pre class='metadata'>
Title: Private Aggregation API
Shortname: private-aggregation-api
Level: 1
Status: UD
Group: patcg-id
Repository: patcg-individual-drafts/private-aggregation-api
URL: https://patcg-individual-drafts.github.io/private-aggregation-api
Editor: Alexander Turner, Google https://www.google.com, alexmt@chromium.org
Abstract: A generic API for measuring aggregate, cross-site data in a privacy
    preserving manner. The potentially identifying cross-site data is
    encapsulated into <em>aggregatable reports</em>. To prevent leakage, this
    data is encrypted, ensuring it can only be processed by an <em>aggregation
    service</em>. During processing, this service will add noise and impose
    limits on how many queries can be performed.
Markup Shorthands: markdown on
Complain About: accidental-2119 on, missing-example-ids on
Assume Explicit For: on
</pre>

<pre class="anchors">
urlPrefix: https://wicg.github.io/turtledove/; type: interface
    text: InterestGroupBiddingScriptRunnerGlobalScope
    text: InterestGroupScriptRunnerGlobalScope
    text: InterestGroupScoringScriptRunnerGlobalScope
    text: InterestGroupReportingScriptRunnerGlobalScope
urlPrefix: https://wicg.github.io/shared-storage/; type: interface
    text: SharedStorageWorklet
    text: SharedStorageWorkletGlobalScope
spec: hr-time; type: dfn; urlPrefix: https://w3c.github.io/hr-time/
    text: current wall time; url: #dfn-current-wall-time
    text: duration; url: #dfn-duration
    text: duration from; url: #dfn-duration-from
    text: moment; url: #dfn-moment
    text: unix epoch; url: #dfn-unix-epoch
    text: wall clock; url: #dfn-wall-clock
spec: html; type: dfn; urlPrefix: https://tc39.es/ecma262/
    text: call; url: sec-call
spec: webdriver; urlPrefix: https://w3c.github.io/webdriver/
    type: dfn
        text: getting a property; url: dfn-getting-properties
        text: error code; url: dfn-error-code
spec: fenced-frame; urlPrefix: https://wicg.github.io/fenced-frame/
    type: dfn;
        for: browsing context;
            text: fenced frame config instance; url: browsing-context-fenced-frame-config-instance
</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:user agent
spec:webidl; type:dfn; text:attribute
</pre>


Introduction {#intro}
=====================

<em>This section is non-normative.</em>

Motivation {#motivation}
------------------------

Browsers are now working to prevent cross-site user tracking, including by
partitioning storage and removing third-party cookies. There are a range of API
proposals to continue supporting legitimate use cases in a way that respects
user privacy. Many of these APIs, including the
<a href="https://wicg.github.io/shared-storage/">Shared Storage API</a> and the
<a href="https://wicg.github.io/turtledove/">Protected Audience API</a>, isolate
potentially identifying cross-site data in special contexts, which ensures that
the data cannot escape the user agent.

Relative to cross-site data from an individual user, aggregate data about groups
of users can be less sensitive and yet would be sufficient for a wide range of
use cases. An aggregation service has been built to allow reporting noisy,
aggregated cross-site data. This service was originally created for use by the
<a href="https://wicg.github.io/attribution-reporting-api/">Attribution
Reporting API</a>, but allowing more general aggregation supports additional use
cases. In particular, the Protected Audience and Shared Storage APIs expect this
functionality to be available.

Overview {#overview}
--------------------

This document outlines a general-purpose API that can be called from isolated
contexts that have access to cross-site data (such as a Shared Storage worklet).
Within these contexts, potentially identifying data can be encapsulated into
"aggregatable reports". To prevent leakage, the cross-site data in these reports
is encrypted to ensure it can only be processed by the aggregation service.
During processing, this service adds noise and imposes limits on how many
queries can be performed.

This API provides functions that allow the origin to construct an aggregatable
report and specify the values to be embedded into its encrypted payload (for
later computation via the aggregation service). These calls result in the
aggregatable report being queued to be sent to the reporting endpoint of the
script's origin after a delay. After the endpoint receives the reports, it will
batch the reports and send them to the aggregation service for processing. The
output of that process is a summary report containing the (approximate) result,
which is dispatched back to the script's origin.

Alternative considered {#alternative-considered}
------------------------------------------------

Instead of the chosen API shape, we considered aligning with a design that is
much closer to {{WindowOrWorkerGlobalScope/fetch()}}. However, there are a few
key differences which make this unfavorable:
- This API is designed to be used in isolated contexts where
    {{WindowOrWorkerGlobalScope/fetch()}} is not available.
- It's an anti-goal to give the developer control over when [=aggregatable
    reports=] are being sent or knowledge that they were sent (outside of the
    isolated context). Note, however, the exception when providing a context ID
    from <em>outside</em> the isolated context, see [Protecting against leaks
    via the number of
    reports](#protecting-against-leaks-via-the-number-of-reports) below.
- The reports cannot be sent to arbitrary reporting endpoints, only a
    particular <code>[[RFC8615|.well-known]]</code> path on the script origin.
- The report's input is very specific (an array of {{PAHistogramContribution}}s)
    and is not amenable to {{WindowOrWorkerGlobalScope/fetch()}}'s general
    purpose contents.
- There is no concept of a response.

So, we chose the more tailored API shape detailed below.

Exposed interface {#exposed-interface}
======================================

<xmp class="idl">
[Exposed=(InterestGroupScriptRunnerGlobalScope,SharedStorageWorklet),
 SecureContext]
interface PrivateAggregation {
  undefined contributeToHistogram(PAHistogramContribution contribution);
  undefined enableDebugMode(optional PADebugModeOptions options = {});
};

dictionary PAHistogramContribution {
  required bigint bucket;
  required long value;
  bigint filteringId = 0;
};

dictionary PADebugModeOptions {
  required bigint debugKey;
};
</xmp>

Issue: Per the <a href=https://www.w3.org/TR/design-principles/#numeric-types>
  Web Platform Design Principles</a>, we should consider switching `long` to
  `[EnforceRange] long long`.

Issue: {{PrivateAggregation/enableDebugMode(options)}}'s argument should not
    have a default value of `{}`. Alternatively, {{PADebugModeOptions/debugKey}}
    should not be required in {{PADebugModeOptions}}.

Each {{PrivateAggregation}} object has the following fields:
<dl dfn-for="PrivateAggregation">
: <dfn>scoping details</dfn> (default null)
:: A [=scoping details=] or null
: <dfn>allowed to use</dfn> (default false)
:: A [=boolean=]

</dl>

Note: See [Exposing to global scopes](#exposing) below.

<div algorithm>
The <dfn method for="PrivateAggregation">
contributeToHistogram(PAHistogramContribution contribution)</dfn> method steps
are:

1. If |contribution|["{{PAHistogramContribution/bucket}}"] is not [=set/
    contained=] in [=the exclusive range|the range=] 0 to 2<sup>128</sup>,
    exclusive, [=exception/throw=] a {{RangeError}}.
1. If |contribution|["{{PAHistogramContribution/value}}"] is negative,
    [=exception/throw=] a {{RangeError}}.
1. Let |scopingDetails| be [=this=]'s [=PrivateAggregation/scoping details=].
1. Let |batchingScope| be the result of running |scopingDetails|' [=scoping
    details/get batching scope steps=].
1. Let |filteringIdMaxBytes| be the [=default filtering ID max bytes=].
1. If [=pre-specified report parameters map=][|batchingScope|] [=map/exists=]:
    1. Set |filteringIdMaxBytes| to [=pre-specified report parameters
        map=][|batchingScope|]'s [=pre-specified report parameters/filtering ID
        max bytes=].
1. If |contribution|["{{PAHistogramContribution/filteringId}}"] is not [=set/
    contained=] in [=the exclusive range|the range=] 0 to
    256<sup>|filteringIdMaxBytes|</sup>, exclusive, [=exception/throw=] a
    {{RangeError}}.
1. Let |entry| be a new [=contribution cache entry=] with the items:
    : [=contribution cache entry/contribution=]
    :: |contribution|
    : [=contribution cache entry/batching scope=]
    :: |batchingScope|
    : [=contribution cache entry/debug scope=]
    :: The result of running |scopingDetails|' [=scoping details/get debug scope
        steps=].

1. [=Append an entry to the contribution cache|Append=] |entry| to the
    [=contribution cache=].

Issue: Ensure errors are of an appropriate type, e.g. {{InvalidAccessError}} is
    deprecated.

Issue(44): Consider accepting an array of contributions.

</div>

<div algorithm>
The <dfn method for="PrivateAggregation">
enableDebugMode(optional PADebugModeOptions options)</dfn> method steps are:

1. Let |scopingDetails| be [=this=]'s [=PrivateAggregation/scoping details=].
1. Let |debugScope| be the result of running |scopingDetails|' [=scoping
    details/get debug scope steps=].
1. If [=debug scope map=][|debugScope|] [=map/exists=], [=exception/throw=] a
    "{{DataError}}" {{DOMException}}.

    Note: This would occur if `enableDebugMode()` has already been run for this
        [=debug scope=].
1. Let |debugKey| be null.
1. If |options| was given:
    1. If |options|["{{PADebugModeOptions/debugKey}}"] is not [=set/contained=]
        in [=the exclusive range|the range=] 0 to 2<sup>64</sup>, exclusive,
        [=exception/throw=] a "{{DataError}}" {{DOMException}}.
    1. Set |debugKey| to |options|["{{PADebugModeOptions/debugKey}}"].
1. Let |debugDetails| be a new [=debug details=] with the items:
    : [=debug details/enabled=]
    :: true
    : [=debug details/key=]
    :: |debugKey|

1. Optionally, set |debugDetails| to a new [=debug details=].

    Note: This allows the user agent to make debug mode unavailable globally or
        just for certain callers.
1. [=map/Set=] [=debug scope map=][|debugScope|] to |debugDetails|.

Issue: Ensure errors are of an appropriate type, e.g. {{InvalidAccessError}} is
    deprecated.
</div>

Exposing to global scopes {#exposing}
=====================================

To expose this API to a global scope, a [=read only=] [=attribute=]
`privateAggregation` of type {{PrivateAggregation}} should be exposed on the
global scope. Its [=getter steps=] should be set to the [=get the
privateAggregation=] steps given [=this=].

Each global scope should set the [=PrivateAggregation/allowed to use=] for the
{{PrivateAggregation}} object it exposes based on whether a relevant
[=document=] is [=allowed to use=] the "<code>[=private-aggregation=]</code>"
[=policy-controlled feature=].

Additionally, each global scope should set the [=PrivateAggregation/scoping
details=] for the {{PrivateAggregation}} object it exposes to a non-null value.
The global scope should wait to set the field until the API is intended to be
available.

<div class="example" id="shared-storage-only-within-operations">
    Shared Storage only allows Private Aggregation when an operation is being
    invoked, not in the top-level context:
    <pre highlight="js">
    class ExampleOperation {
      async run(data) {
        privateAggregation.contributeToHistogram(...)  // This is allowed.
      }
    }
    register('example-operation', ExampleOperation);

    privateAggregation.contributeToHistogram(...)  // This would cause an error.
    </pre>
    So, Shared Storage sets the [=PrivateAggregation/scoping details=]
    immediately after the initial execution of the module script is complete.
</div>

For any [=batching scope=] returned by the [=scoping details/get batching scope
steps=], the [=process contributions for a batching scope=] steps should later
be performed given that same batching scope, the global scope's [=relevant
settings object=]'s [=environment settings object/origin=], some [=context
type=] and a timeout (or null).

Note: This last requirement means that global scopes with different origins
    cannot share the same batching scope, see [Same-origin
    policy](#same-origin-policy) discussion.

For any [=debug scope=] returned by the [=scoping details/get debug scope
steps=], the [=mark a debug scope complete=] steps should later be performed
given that same [=debug scope=].

Note: A later algorithm [=asserts=] that, for any [=contribution cache entry=]
    in the [=contribution cache=], the [=mark a debug scope complete=] steps
    were performed given the entry's [=contribution cache entry/debug scope=]
    before the [=process contributions for a batching scope=] steps are
    performed given the entry's [=contribution cache entry/batching scope=].

Structures {#structures}
========================

<h3 dfn-type=dfn>Batching scope</h3>
A batching scope is a <a spec=HTML>unique internal value</a> that identifies
which {{PAHistogramContribution}}s should be sent in the same [=aggregatable
report=] unless their [=aggregatable report/debug details=] differ.

Issue: Unique internal value is not an exported definition. See
    <a href="https://github.com/whatwg/infra/issues/583">infra/583</a>.

<h3 dfn-type=dfn>Debug scope</h3>
A debug scope is a <a spec=HTML>unique internal value</a> that identifies which
{{PAHistogramContribution}}s should have their [=debug details=] affected by the
presence or absence of a call to {{PrivateAggregation/enableDebugMode()}} in the
same period of execution.

<h3 dfn-type=dfn>Scoping details</h3>
A scoping details is a [=struct=] with the following items:
<dl dfn-for="scoping details">
: <dfn>get batching scope steps</dfn>
:: An algorithm returning a [=batching scope=]
: <dfn>get debug scope steps</dfn>
:: An algorithm returning a [=debug scope=]

</dl>

<h3 dfn-type=dfn>Debug details</h3>
A debug details is a [=struct=] with the following items:
<dl dfn-for="debug details">
: <dfn>enabled</dfn> (default false)
:: A [=boolean=]
: <dfn>key</dfn> (default null)
:: An unsigned 64-bit integer or null. The key must be null if [=debug
    details/enabled=] is false.

</dl>

<h3 dfn-type=dfn>Contribution cache entry</h3>
A contribution cache entry is a [=struct=] with the following items:
<dl dfn-for="contribution cache entry">
: <dfn>contribution</dfn>
:: A {{PAHistogramContribution}}
: <dfn>batching scope</dfn>
:: A [=batching scope=]
: <dfn>debug scope</dfn>
:: A [=debug scope=]
: <dfn>debug details</dfn> (default null)
:: A [=debug details=] or null

</dl>

<h3 dfn-type=dfn>Aggregatable report</h3>

An aggregatable report is a [=struct=] with the following items:
<dl dfn-for="aggregatable report">
: <dfn>reporting origin</dfn>
:: An [=origin=]
: <dfn>original report time</dfn>
:: A [=moment=]
: <dfn>report time</dfn>
:: A [=moment=]
: <dfn>contributions</dfn>
:: A [=list=] of {{PAHistogramContribution}}s
: <dfn>api</dfn>
:: A [=context type=]
: <dfn>report ID</dfn>
:: A [=string=]
: <dfn>debug details</dfn>
:: A [=debug details=]
: <dfn>aggregation coordinator</dfn>
:: An [=aggregation coordinator=]
: <dfn>context ID</dfn>
:: A [=string=] or null
: <dfn>filtering ID max bytes</dfn>
:: A positive integer
: <dfn>queued</dfn>
:: A [=boolean=]

</dl>

Aggregation coordinator {#aggregation-coordinator-structure}
------------------------------------------------------------

An <dfn>aggregation coordinator</dfn> is an [=origin=] that the [=allowed
aggregation coordinator set=] [=set/contains=].

Issue: Consider switching to the <a spec="attribution-reporting-api">suitable
origin</a> concept used by the Attribution Reporting API here and elsewhere.

Issue: Move other structures to be defined inline instead of via a header.
    Consider also removing all the subheadings.

<h3 dfn-type=dfn>Context type</h3>
A context type is a [=string=] indicating what kind of global scope the
{{PrivateAggregation}} object was exposed in. Each API exposing Private
Aggregation should pick a unique string (or multiple) for this.

Pre-specified report parameters {#pre-specified-report-parameters-structure}
----------------------------------------------------------------------------

A <dfn>pre-specified report parameters</dfn> is a [=struct=] with the following
items:
<dl dfn-for="pre-specified report parameters">
: <dfn>context ID</dfn> (default: null)
:: A [=string=] or null
: <dfn>filtering ID max bytes</dfn> (default: [=default filtering ID max bytes=])
:: A positive integer

</dl>

Storage {#storage}
==================

A [=user agent=] holds an <dfn>aggregatable report cache</dfn>, which is a
[=list=] of [=aggregatable reports=].

A [=user agent=] holds an <dfn>aggregation coordinator map</dfn>, which is a
[=map=] from [=batching scopes=] to [=aggregation coordinators=].

A [=user agent=] holds a <dfn>pre-specified report parameters map</dfn>, which
is a [=map=] from [=batching scopes=] to [=pre-specified report parameters=].

A [=user agent=] holds a <dfn>contribution cache</dfn>, which is a [=list=] of
[=contribution cache entries=].

A [=user agent=] holds a <dfn>debug scope map</dfn>, which is a [=map=] from
[=debug scopes=] to [=debug details=].

Issue: Elsewhere, link to definition when using [=user agent=].

Clearing storage {#clearing-storage}
----------------------------------------

The user agent must expose controls that allow the user to delete data from
the [=aggregatable report cache=] as well as any contribution history data
stored for the [=consume budget if permitted=] algorithm.

The user agent may expose controls that allow the user to delete data from the
[=contribution cache=], the [=debug scope map=] and the [=pre-specified report
parameters map=].

Constants {#constants}
======================

<dfn>Default filtering ID max bytes</dfn> is a positive integer controlling the
max bytes used if none is explicitly chosen. Its value is 1.

<dfn>Valid filtering ID max bytes range</dfn> is a [=set=] of positive integers
controlling the allowable values of max bytes. Its value is [=the inclusive
range|the range=] 1 to 8, inclusive.

Issue: Consider adding more constants.

[=Implementation-defined=] values {#implementation-defined-values}
==================================================================

<dfn>Allowed aggregation coordinator set</dfn> is a [=set=] of [=origins=] that
controls which [=origins=] are valid [=aggregation coordinators=]. Every
[=set/item=] in this [=set=] must be a [=potentially trustworthy origin=].

<dfn>Default aggregation coordinator</dfn> is an [=aggregation coordinator=]
that controls which is used for a report if none is explicitly selected.

<dfn>Maximum report contributions</dfn> is a [=map=] from [=context type=] to
positive integers. Semantically, it defines the maximum number of contributions
that can be present in a single report for every kind of calling context, e.g.
Shared Storage.

<dfn>Minimum report delay</dfn> is a non-negative [=duration=] that controls the
minimum delay to deliver an [=aggregatable report=].

<dfn>Randomized report delay</dfn> is a positive [=duration=] that controls the
random delay to deliver an [=aggregatable report=]. This delay is additional to
the [=minimum report delay=].

Permissions Policy integration {#permissions-policy-integration}
================================================================

This specification defines a [=policy-controlled feature=] identified by the
string "<code><dfn>private-aggregation</dfn></code>". Its [=policy-controlled
feature/default allowlist=] is "`*`".

Note: The [=PrivateAggregation/allowed to use=] field is set by other
    specifications that integrate with this API according to this
    [=policy-controlled feature=].

Algorithms {#algorithms}
====================

To <dfn>serialize an integer</dfn>, represent it as a [=string=] of the shortest
possible decimal number.

Issue: This would ideally be replaced by a more descriptive algorithm in Infra.
    See <a href="https://github.com/whatwg/infra/issues/201">infra/201</a>.

Exported algorithms {#exported-algorithms}
------------------------------------------

Note: These algorithms allow other specifications to integrate with this API.

<div algorithm>
To <dfn export>get the privateAggregation</dfn> given a
{{PrivateAggregation}} |this|:
1. Let |scopingDetails| be |this|'s [=PrivateAggregation/scoping details=].
1. If |scopingDetails| is null, [=exception/throw=] a "{{NotAllowedError}}"
    {{DOMException}}.

    Note: This indicates the API is not yet available, for example, because the
        initial execution of the script after loading is not complete.

    Issue: Consider improving developer ergonomics here (e.g. a way to detect
        this case).
1. If |this|'s [=PrivateAggregation/allowed to use=] is false, [=exception/
    throw=] an "{{InvalidAccessError}}" {{DOMException}}.
1. Return |this|.

Issue: Ensure errors are of an appropriate type, e.g. {{InvalidAccessError}} is
    deprecated.
</div>

<div algorithm>
To <dfn export>append an entry to the contribution cache</dfn> given a
[=contribution cache entry=] |entry|:
1. [=list/Append=] |entry| to the [=contribution cache=].

</div>

<div algorithm>
To <dfn export>get a debug details</dfn> given a [=debug scope=]
|debugScope|, perform the following steps. They return a [=debug details=].
1. If [=debug scope map=][|debugScope|] [=map/exists=], return
    [=debug scope map=][|debugScope|].
1. Otherwise, return a new [=debug details=].

</div>

<div algorithm>
To <dfn export>mark a debug scope complete</dfn> given a [=debug
scope=] |debugScope| and an optional [=debug details=] or null
|debugDetailsOverride| (default null):
1. Let |debugDetails| be |debugDetailsOverride|.
1. If [=debug scope map=][|debugScope|] [=map/exists=]:
    1. [=Assert=]: |debugDetailsOverride| is null.

        Note: The override can be provided if the debug details have not been
            set otherwise.
    1. Set |debugDetails| to [=debug scope map=][|debugScope|].
    1. [=map/Remove=] [=debug scope map=][|debugScope|].
    1. If |debugDetails|'s [=debug details/key=] is not null, [=assert=]:
        |debugDetails|'s [=debug details/enabled=] is true.
1. If |debugDetails| is null, set |debugDetails| to a new [=debug details=].
1. [=list/iterate|For each=] |entry| of the [=contribution cache=]:
    1. If |entry|'s [=contribution cache entry/debug scope=] is |debugScope|,
        set |entry|'s [=contribution cache entry/debug details=] to
        |debugDetails|.

</div>

<div algorithm>
To <dfn>determine if a report should be sent deterministically</dfn> given a
[=pre-specified report parameters=] |preSpecifiedParams|, perform the following
steps. They return a [=boolean=]:
1. If |preSpecifiedParams|' [=pre-specified report parameters/context ID=] is
    not null, return true.
1. If |preSpecifiedParams|' [=pre-specified report parameters/filtering ID max
    bytes=] is not the [=default filtering ID max bytes=], return true.
1. Return false.

Note: If a context ID or non-default filtering ID max bytes was specified, a
    report is sent, even if there are no contributions or there is insufficent
    budget for the requested contributions. See [Protecting against leaks via
    the number of reports](#protecting-against-leaks-via-the-number-of-reports).
</div>

<div algorithm>
To <dfn export>process contributions for a batching scope</dfn> given
a [=batching scope=] |batchingScope|, an [=origin=] |reportingOrigin|, a
[=context type=] |contextType| and a [=moment=] or null |timeout|:
1. Let |batchEntries| be a new [=list=].
1. [=list/iterate|For each=] |entry| of the [=contribution cache=]:
    1. If |entry|'s [=contribution cache entry/batching scope=] is
        |batchingScope|:
        1. [=Assert=]: |entry|'s [=contribution cache entry/debug details=] is
            not null.

            Note: This asserts that the [=mark a debug scope complete=] steps
                were run before the [=process contributions for a batching
                scope=] steps.

        1. [=list/Append=] |entry| to |batchEntries|.
1. Let |aggregationCoordinator| be the [=default aggregation coordinator=].
1. If [=aggregation coordinator map=][|batchingScope|] [=map/exists=]:
    1. Set |aggregationCoordinator| to [=aggregation coordinator
        map=][|batchingScope|].
    1. [=map/Remove=] [=aggregation coordinator map=][|batchingScope|].
1. Let |preSpecifiedParams| be a new [=pre-specified report parameters=].
1. If [=pre-specified report parameters map=][|batchingScope|] [=map/exists=]:
    1. Set |preSpecifiedParams| to [=pre-specified report parameters
        map=][|batchingScope|].
    1. [=map/Remove=] [=pre-specified report parameters map=][|batchingScope|].
1. Let |isDeterministicReport| be the result of [=determining if a report should
    be sent deterministically=] given |preSpecifiedParams|.
1. If |isDeterministicReport| is false, [=assert=]: |timeout| is null.

    Note: Timeouts can only be used for deterministic reports.
1. If |batchEntries| [=list/is empty=] and |isDeterministicReport| is false,
    return.
1. Let |batchedContributions| be a new [=ordered map=].
1. [=list/iterate|For each=] |entry| of |batchEntries|:
    1. [=list/Remove=] |entry| from the [=contribution cache=].
    1. Let |debugDetails| be |entry|'s [=contribution cache entry/debug
        details=].
    1. If |batchedContributions|[|debugDetails|] does not [=map/exist=]:
        1. [=map/Set=] |batchedContributions|[|debugDetails|] to a new [=list=].
    1. [=list/Append=] |entry|'s [=contribution cache entry/contribution=] to
        |batchedContributions|[|debugDetails|].
1. If |batchedContributions| [=map/is empty=]:
    1. Let |debugDetails| be a new [=debug details=].
    1. Set |batchedContributions|[|debugDetails|] to a new [=list=].
1. [=map/iterate|For each=] |debugDetails| → |contributions| of
    |batchedContributions|:
    1. Perform the [=report creation and scheduling steps=] with
        |reportingOrigin|, |contextType|, |contributions|, |debugDetails|,
        |aggregationCoordinator|, |preSpecifiedParams| and |timeout|.

Note: These steps break up the contributions based on their [=debug details=] as
    each report can only have one set of metadata.
</div>

<div algorithm>
To <dfn export>determine if an origin is an aggregation coordinator</dfn> given
an [=origin=] |origin|, perform the following steps. They return a [=boolean=].

1. Return whether |origin| is an [=aggregation coordinator=].

</div>

<div algorithm>
To <dfn export>set the aggregation coordinator for a batching scope</dfn> given
an [=origin=] |origin| and a [=batching scope=] |batchingScope|:

1. [=Assert=]: |origin| is an [=aggregation coordinator=].
1. [=map/Set=] [=aggregation coordinator map=][|batchingScope|] to |origin|.

</div>

Issue: Elsewhere, surround algorithms in a `<div algorithm>` block to match, and
    add styling for all algorithms per
    [bikeshed/1472](https://github.com/speced/bikeshed/issues/1472).

<div algorithm>
To <dfn export>set the pre-specified report parameters for a batching
scope</dfn> given a [=pre-specified report parameters=] |params| and a
[=batching scope=] |batchingScope|:

1. Let |contextId| be |params|' [=pre-specified report parameters/context ID=].
1. [=Assert=]: |contextId| is null or |contextId|'s [=string/length=] is not
    larger than 64.
1. Let |filteringIdMaxBytes| be |params|' [=pre-specified report parameters/
    filtering ID max bytes=].
1. [=Assert=]: |filteringIdMaxBytes| is [=set/contained=] in the [=valid
    filtering ID max bytes range=]
1. [=map/Set=] [=pre-specified report parameters map=][|batchingScope|] to
    |params|.

</div>

Scheduling reports {#scheduling-reports}
----------------------------------------

<div algorithm>
To perform the <dfn>report creation and scheduling steps</dfn> with an
[=origin=] |reportingOrigin|, a [=context type=] |api|, a [=list=] of
{{PAHistogramContribution}}s |contributions|, a [=debug details=]
|debugDetails|, an [=aggregation coordinator=] |aggregationCoordinator|, a
[=pre-specified report parameters=] |preSpecifiedParams| and a [=moment=] or
null |timeout|:
1. [=Assert=]: |reportingOrigin| is a [=potentially trustworthy origin=].
1. Optionally, return.

    Note: This [=implementation-defined=] condition is intended to allow [=user
        agents=] to drop reports for a number of reasons, for example user
        opt-out or an origin not being
        <a href="https://github.com/privacysandbox/attestation">enrolled</a>.
1. Let |mergedContributions| be a new [=list=].
1. [=list/For each=] |contribution| of |contributions|:
    1. Let |hasProcessedContribution| be false.
    1. [=list/For each=] |mergedContribution| of |mergedContributions|:
        1. If |contribution| and |mergedContribution| have both the same
            {{PAHistogramContribution/bucket}} and the same
            {{PAHistogramContribution/filteringId}}:
            1. Add |contribution|'s {{PAHistogramContribution/value}} to
                |mergedContribution|'s {{PAHistogramContribution/value}}.
            1. Set |hasProcessedContribution| to true.
            1. [=iteration/Break=].
    1. If |hasProcessedContribution| is false, [=list/append=] |contribution| to
        |mergedContributions|.
1. Let |truncatedContributions| be a new [=list=].
1. If |mergedContributions| has a [=list/size=] greater than [=maximum report
    contributions=][|api|]:
    1. [=set/For each=] |n| of [=the exclusive range|the range=] 0 to [=maximum
        report contributions=][|api|], exclusive:
        1. [=set/Append=] |mergedContributions|[|n|] to
            |truncatedContributions|.
1. Otherwise, set |truncatedContributions| to |mergedContributions|.
1. Let |contributionSum| be 0.
1. [=set/iterate|For each=] |contribution| of |truncatedContributions|:
    1. [=Assert=]: |contribution|["{{PAHistogramContribution/value}}"] is
        non-negative.
    1. Add |contribution|["{{PAHistogramContribution/value}}"] to
        |contributionSum|.
1. Let |currentWallTime| be the [=current wall time=].
1. Let |sufficientBudget| be the result of [=consuming budget if permitted=]
    given |contributionSum|, |reportingOrigin|, |api| and |currentWallTime|.

    Issue: Allow for some of the contributions to still be approved even if
        there isn't enough budget for the entire report. Note that this change
        would require the merging step to be postponed until after budgeting and
        the truncation step modified to account for the later merging.
1. If |sufficientBudget| is false:
    1. Let |isDeterministicReport| be the result of [=determining if a report
        should be sent deterministically=] given |preSpecifiedParams|.
    1. If |isDeterministicReport| is false, return.
    1. [=list/Empty=] |truncatedContributions|.
1. Let |report| be the result of [=obtaining an aggregatable report=] given
    |reportingOrigin|, |api|, |truncatedContributions|, |debugDetails|,
    |aggregationCoordinator|, |preSpecifiedParams|, |timeout| and
    |currentWallTime|.
1. [=set/Append=] |report| to the user agent's [=aggregatable report cache=].

</div>

<div algorithm>
To <dfn>consume budget if permitted</dfn> given an integer |value|, an
[=origin=] <var ignore>origin</var>, a [=context type=] <var ignore>api</var> and a
[=moment=] <var ignore>currentTime</var>, perform [=implementation-defined=] steps. They return
a [=boolean=], which indicates whether there is sufficient 'contribution budget'
left to send the requested contribution |value| (or multiple contributions with
a sum of values equal to |value|). This budget should be bound to
usage over time, e.g. the contribution sum over the last 24 hours. The algorithm
should assume that the contribution will be sent if and only if true is
returned, i.e. it should consume the budget in that case. If |value| is zero,
this algorithm should return true.
</div>

<div algorithm>
To <dfn>obtain an aggregatable report</dfn> given an [=origin=]
|reportingOrigin|, a [=context type=] |api|, a [=list=] of
{{PAHistogramContribution}}s |contributions|, a [=debug details=]
|debugDetails|, an [=aggregation coordinator=] |aggregationCoordinator|, a
[=pre-specified report parameters=] |preSpecifiedParams|, a [=moment] or null
|timeout| and a [=moment=] |currentTime|,
perform the following steps. They return an [=aggregatable report=].
1. [=Assert=]: |reportingOrigin| is a [=potentially trustworthy origin=].
1. Let |reportTime| be the result of running [=obtain a report delivery time=]
    given |currentTime| and |timeout|.
1. Let |report| be a new [=aggregatable report=] with the items:
    : [=aggregatable report/reporting origin=]
    :: |reportingOrigin|
    : [=aggregatable report/original report time=]
    :: |reportTime|
    : [=aggregatable report/report time=]
    :: |reportTime|
    : [=aggregatable report/contributions=]
    :: |contributions|
    : [=aggregatable report/api=]
    :: |api|
    : [=aggregatable report/report ID=]
    :: The result of [=generating a random UUID=].
    : [=aggregatable report/debug details=]
    :: |debugDetails|
    : [=aggregatable report/aggregation coordinator=]
    :: |aggregationCoordinator|
    : [=aggregatable report/context ID=]
    :: |preSpecifiedParams|' [=pre-specified report parameters/context ID=]
    : [=aggregatable report/filtering ID max bytes=]
    :: |preSpecifiedParams|' [=pre-specified report parameters/filtering ID max
        bytes=]
    : [=aggregatable report/queued=]
    :: false
1. Return |report|.

</div>

<div algorithm>
To <dfn>obtain a report delivery time</dfn> given a [=moment=]
|currentTime| and a [=moment=] or null |timeout|, perform the following steps.
They return a [=moment=].

1. If |timeout| is not null:
    1. Return |timeout|.
1. If [=automation local testing mode enabled=] is true, return
    |currentTime|.
1. Let |r| be a random double between 0 (inclusive) and 1 (exclusive) with
    uniform probability.
1. Return |currentTime| + [=minimum report delay=] + |r| * [=randomized report
    delay=].

</div>

Sending reports {#sending-reports}
----------------------------------

Note: This section is largely copied from the
    <a href="https://wicg.github.io/attribution-reporting-api/">Attribution
    Reporting API spec</a>, adapting as necessary.


Issue: Do we have to use the [=queue a task=] algorithm here?

The user agent must periodically [=attempt to queue reports for sending=] given
its [=aggregatable report cache=].

<div algorithm>
To <dfn>attempt to queue reports for sending</dfn> given a [=list=] of
[=aggregatable reports=] |reports|:
1. [=list/iterate|For each=] |report| of |reports|, run these steps [=in
    parallel=]:
    1. Run these steps, but [=abort when=] the [=user agent=] shuts down:
        1. If |report|'s [=aggregatable report/queued=] value is true, return.
        1. Set |report|'s [=aggregatable report/queued=] value to true.
        1. Let |currentWallTime| be the [=current wall time=].
        1. If |report|'s [=aggregatable report/report time=] is before
            |currentWallTime|, set |report|'s [=aggregatable report/report
            time=] to |currentWallTime| plus an [=implementation-defined=]
            random non-negative [=duration=].

            Note: On startup, it is possible the user agent will need to send
                many reports whose report times passed while the browser was
                closed. Adding random delay prevents temporal joining of
                reports.
        1. Wait until the [=current wall time=] is equal to or after |report|'s
            [=aggregatable report/report time=].
        1. Optionally, wait a further [=implementation-defined=] non-negative
            [=duration=].

            Note: This is intended to allow user agents to optimize device
                resource usage and wait for the user agent to be online.
        1. Run [=attempt to deliver a report=] with |report|.
    1. [=If aborted=], set |report|'s [=aggregatable report/queued=] value to
        false.

        Note: It might be more practical to perform this step when the [=user
            agent=] next starts up.

</div>

<div algorithm>
To <dfn>attempt to deliver a report</dfn> given an [=aggregatable report=]
|report|:
1. Let |url| be the result of [=obtaining a reporting endpoint=] given
    |report|'s [=aggregatable report/reporting origin=] and |report|'s
    [=aggregatable report/api=].
1. Let |data| be the result of [=serializing an aggregatable report=] given
    |report|.
1. If |data| is an error, [=list/remove=] |report| from the [=aggregatable
    report cache=].

    Issue: Do we need to queue this task?
1. Let |request| be the result of [=creating a report request=] given |url| and
    |data|.
1. [=Queue a task=] to [=fetch=] |request| with [=fetch/processResponse=] being
    the following steps:
    1. Let |shouldRetry| be an [=implementation-defined=] [=boolean=]. The value
        should be false if no error occurred.
    1. If |shouldRetry| is true:
        1. Set |report|'s [=aggregatable report/report time=] to the [=current
            wall time=] plus an [=implementation-defined=] non-negative
            [=duration=].
        1. Set |report|'s [=aggregatable report/queued=] value to false.
    1. Otherwise, [=list/remove=] |report| from the [=aggregatable report
        cache=].

</div>

<div algorithm>
To <dfn>obtain a reporting endpoint</dfn> given an [=origin=] |reportingOrigin|
and [=context type=] |api|, perform the following steps. They return a [=URL=].
1. [=Assert=]: |reportingOrigin| is a [=potentially trustworthy origin=].
1. Let |path| be the [=string/concatenation=] of
    «"<code>[[RFC8615|.well-known]]/private-aggregation/report-</code>", |api|».

    Issue(67): Register this well-known directory.
1. Let |base| be the result on running the [=URL parser=] on the [=serialization
    of an origin|serialization=] of |reportingOrigin|.
1. [=Assert=]: |base| is not failure.
1. Let |result| be the result of running the [=URL parser=] on |path| with
    |base|.
1. [=Assert=]: |result| is not failure.
1. Return |result|.

</div>

<div algorithm>
To <dfn>create a report request</dfn> given a [=URL=] |url| and a [=byte
sequence=] |body|:
1. Let |request| be a new [=request=] with the following properties:
    :   [=request/method=]
    ::  "`POST`"
    :   [=request/URL=]
    ::  |url|
    :   [=request/header list=]
    ::  «("`Content-Type`", "`application/json`")»
    :   [=request/unsafe-request flag=]
    ::  set
    :   [=request/body=]
    ::  |body|
    :   [=request/client=]
    ::  `null`
    :   [=request/window=]
    ::  "`no-window`"
    :   [=request/service-workers mode=]
    ::  "`none`"
    :   [=request/initiator=]
    ::  ""
    :   [=request/referrer=]
    :: "`no-referrer`"
    :   [=request/mode=]
    ::  "`cors`"
    :   [=request/credentials mode=]
    ::  "`omit`"
    :   [=request/cache mode=]
    ::  "`no-store`"
1. Return |request|.

</div>

Serializing reports {#serializing-reports}
------------------------------------------

Note: This section is largely copied from the
    <a href="https://wicg.github.io/attribution-reporting-api/">Attribution
    Reporting API spec</a>, adapting as necessary.

<div algorithm>
To <dfn>serialize an aggregatable report</dfn> given an [=aggregatable report=]
|report|, perform the following steps. They return a [=byte sequence=] or an
error.
1. Let |aggregationServicePayloads| be the result of [=obtaining the aggregation
    service payloads=] given |report|.
1. If |aggregationServicePayloads| is an error, return
    |aggregationServicePayloads|.
1. Let |data| be an [=ordered map=] of the following key/value pairs:
    : "`aggregation_coordinator_origin`"
    :: |report|'s [=aggregatable report/aggregation coordinator=],
        [=serialization of an origin|serialized=].
    : "`aggregation_service_payloads`"
    :: |aggregationServicePayloads|
    : "`shared_info`"
    :: The result of [=obtaining a report's shared info=] given |report|.
1. Let |debugKey| be |report|'s [=aggregatable report/debug details=]'s [=debug
    details/key=].
1. If |debugKey| is not null, [=map/set=] |data|["`debug_key`"] to |debugKey|.
1. Let |contextId| be |report|'s [=aggregatable report/context ID=].
1. If |contextId| is not null, [=map/set=] |data|["`context_id`"] to
    |contextId|.
1. Return the [=byte sequence=] resulting from executing [=serialize an infra
    value to JSON bytes=] on |data|.

</div>

<div algorithm>
To <dfn>obtain the aggregation service payloads</dfn> given an [=aggregatable
report=] |report|, perform the following steps. They return a [=list=] of
[=maps=] or an error.
1. Let |publicKeyTuple| be the result of [=obtaining the public key for
    encryption=] given |report|'s [=aggregatable report/aggregation
    coordinator=].
1. If |publicKeyTuple| is an error, return |publicKeyTuple|.
1. Let (|pkR|, |keyId|) be |publicKeyTuple|.
1. Let |plaintextPayload| be the result of [=obtaining the plaintext payload=]
    given |report|.
1. Let |sharedInfo| be the result of [=obtaining a report's shared info=] given
    |report|.
1. Let |encryptedPayload| be the result of [=encrypting the payload=] given
    |plaintextPayload|, |pkR| and |sharedInfo|.
1. If |encryptedPayload| is an error, return |encryptedPayload|.
1. Let |aggregationServicePayloads| be a new [=list=].
1. Let |aggregationServicePayload| be an [=ordered map=] of the following
    key/value pairs:
    : "`key_id`"
    :: |keyId|
    : "`payload`"
    :: |encryptedPayload|, [=forgiving-base64 encode|base64 encoded=]
1. If |report|'s [=aggregatable report/debug details=]'s [=debug details/
    enabled=] field is true:
    1. [=map/Set=] |aggregationServicePayload|[`debug_cleartext_payload`] to
        |plaintextPayload|, [=forgiving-base64 encode|base64 encoded=].
1. [=list/Append=] |aggregationServicePayload| to |aggregationServicePayloads|.
1. Return |aggregationServicePayloads|.

</div>

<div algorithm>
To <dfn>obtain the public key for encryption</dfn> given an [=aggregation
coordinator=] |aggregationCoordinator|, perform the following steps. They return
a [=tuple=] consisting of a public key and a [=string=], or an error.

1. Let |url| be a new [=URL record=].
1. Set |url|'s [=url/scheme=] to |aggregationCoordinator|'s [=origin/scheme=].
1. Set |url|'s [=url/host=] to |aggregationCoordinator|'s [=origin/host=].
1. Set |url|'s [=url/port=] to |aggregationCoordinator|'s [=origin/port=].
1. Set |url|'s [=url/path=]  to «"`.well-known`", "`aggregation-service`",
    "`v1`", "`public-keys`"».
1. Return an [=implementation-defined=] [=tuple=] consisting of a public key
    from |url| and a [=string=] that should uniquely identify the public key or,
    in the event that the user agent failed to obtain the public key from |url|,
    an error. This step may be asynchronous.

Issue: Specify this in terms of [=fetch=]. Add details about which encryption
    standards to use, length requirements, etc.

Note: The user agent is encouraged to enforce regular key rotation. If there are
    multiple keys, the user agent can independently pick a key uniformly at
    random for every encryption operation.

</div>

<div algorithm>
To <dfn>obtain the plaintext payload</dfn> given an [=aggregatable report=]
    |report|, perform the following steps. They return a [=byte sequence=].
1. Let |payloadData| be a new [=list=].
1. Let |contributions| be |report|'s [=aggregatable report/contributions=].
1. Let |maxContributions| be
    [=maximum report contributions=][[=aggregatable report/api=]].
1. [=Assert=]: |contributions|' [=list/size=] is not greater than
    |maxContributions|.
1. [=iteration/While=] |contributions|' [=list/size=] is less than
    |maxContributions|:
    1. Let |nullContribution| be a new {{PAHistogramContribution}} with the
        items:
        : {{PAHistogramContribution/bucket}}
        :: 0
        : {{PAHistogramContribution/value}}
        :: 0
        : {{PAHistogramContribution/filteringId}}
        :: 0
    1. [=list/Append=] |nullContribution| to |contributions|.

    Note: This padding protects against the number of contributions being leaked
        through the encrypted payload size, see discussion
        [below](#protecting-against-leaks-via-payload-size).
1. [=list/iterate|For each=] |contribution| of |report|'s [=aggregatable report/
    contributions=]:
    1. Let |filteringIdMaxBytes| be |report|'s [=aggregatable report/filtering
        id max bytes=].
    1. [=Assert=]: |contribution|["{{PAHistogramContribution/filteringId}}"]
        is [=set/contained=] in [=the exclusive range|the range=] 0 to
        256<sup>|filteringIdMaxBytes|</sup>, exclusive.
    1. Let |contributionData| be an [=ordered map=] of the following key/value
        pairs:
        : "`bucket`"
        :: The result of [=encoding an integer for the payload=] given
            |contribution|["{{PAHistogramContribution/bucket}}"] and 16.
        : "`value`"
        :: The result of [=encoding an integer for the payload=] given
            |contribution|["{{PAHistogramContribution/value}}"] and 4.
        : "`id`"
        :: The result of [=encoding an integer for the payload=] given
            |contribution|[="{{PAHistogramContribution/filteringId}}"] and
            |filteringIdMaxBytes|.
    1. [=list/Append=] |contributionData| to |payloadData|.
1. Let |payload| be an [=ordered map=] of the following key/value pairs:
    : "`data`"
    :: |payloadData|
    : "`operation`"
    :: "`histogram`"
1. Return the [=byte sequence=] resulting from [[!RFC8949|CBOR encoding]]
    |payload|.

</div>

<div algorithm>
To <dfn>encrypt the payload</dfn> given a [=byte sequence=] |plaintextPayload|,
public key |pkR| and a [=string=] |sharedInfo|, perform the following steps.
They return a [=byte sequence=] or an error.

1. Let |info| be the result of [=UTF-8 encoding=] the [=string/concatenation=]
    of « "`aggregation_service`", |sharedInfo| ».
1. Let (|kem_id|, |kdf_id|, |aead_id|) be (0x0020, 0x0001, 0x0003).

    Note: The ciphersuite triple above is composed of [[RFC9180|HPKE]]
        [[RFC9180#name-algorithm-identifiers|algorithm identifiers]], specifying
        the [[RFC9180#name-key-encapsulation-mechanism|KEM]] as DHKEM(X25519,
        HKDF-SHA256), the [[RFC9180#name-key-derivation-functions-kd|KDF]]
        function as HKDF-SHA256 and the
        [[RFC9180#name-authenticated-encryption-wi|AEAD]] function as
        ChaCha20Poly1305.
1. Let (|enc|, |hpkeContext|) be the result of setting up an [[RFC9180|HPKE]]
    [[RFC9180#name-encryption-to-a-public-key|sender's context]] by calling
    `SetupBaseS()` with a public key |pkR|, application-supplied information
    |info|, KEM |kem_id|, KDF |kdf_id|, and AEAD |aead_id|. If this operation
    fails, return an error.

     Note: For clarity, we explicitly passed the KEM, KDF, and AEAD identifiers
     to `SetupBaseS()` above, even though RFC9180 omits the parameters from its
     pseudocode.
1. Let |aad| be \`\` (an empty [=byte sequence=]).
1. Let |ciphertext| be the result of
    [[RFC9180#name-encryption-and-decryption|sealing]] the payload by calling
    `ContextS.Seal()` on the |hpkeContext| object with additional authenticated
    data |aad| and plaintext |plaintextPayload|. If this operation fails, return
    an error.
1. Let |encryptedPayload| be the concatenation of the [=byte sequences=] «
    |enc|, |ciphertext| ».

    Note: The length of the encapsulated symmetric key <var ignore>enc</var>
     generated by our chosen KEM is exactly 32 bytes, as shown in RFC9180's
     table of [[RFC9180#name-key-encapsulation-mechanism|KEM IDs]].
1. Return the [=byte sequence=] |encryptedPayload|.

</div>

<div algorithm>
To <dfn>encode an integer for the payload</dfn> given an integer |intToEncode|
and an integer |byteLength|, return the representation of |intToEncode| as a
big-endian [=byte sequence=] of length |byteLength|, left padding with zeroes as
necessary.

</div>

<div algorithm>
To <dfn>obtain a report's shared info</dfn> given an [=aggregatable report=]
|report|, perform the following steps. They return a [=string=].
1. Let |scheduledReportTime| be the [=duration from=] the [=UNIX epoch=] to
    |report|'s [=aggregatable report/original report time=].
1. Let |sharedInfo| be an [=ordered map=] of the following key/value pairs:
    : "`api`"
    :: |report|'s [=aggregatable report/api=]
    : "`report_id`"
    :: |report|'s [=aggregatable report/report ID=]
    : "`reporting_origin`"
    :: The [=serialization of an origin|serialization=] of |report|'s
        [=aggregatable report/reporting origin=]
    : "`scheduled_report_time`"
    :: The number of seconds in |scheduledReportTime|, rounded down to the
        nearest number of whole seconds and [=serialize an integer|serialized=]
    : "`version`"
    :: "`1.0`"
1. Return the result of [=serializing an infra value to a json string=] given
    |sharedInfo|.

</div>

User-agent automation {#user-agent-automation}
==============================================

A user agent holds a boolean <dfn>automation local testing mode enabled</dfn>
(default false).

For the purposes of user-agent automation and website testing, this document
defines the below [[WebDriver]] [=extension commands=] to control the API
configuration.

Set local testing mode {#set-local-testing-mode}
------------------------------------------------

<figure id="table-webdriver-setlocaltestingmode" class="table">
    <table class="data">
        <thead>
            <tr>
                <th>HTTP Method</th>
                <th>URI Template</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>POST</td>
                <td>`/session/{session id}/private-aggregation/`<dfn
                    noexport>`localtestingmode`</dfn></td>
            </tr>
        </tbody>
    </table>
</figure>

<div algorithm>
The <dfn export>remote end steps</dfn> are:

1. If |parameters| is not a JSON-formatted [[ECMASCRIPT#sec-objects|Object]],
    return a [=error|WebDriver error=] with [=error code=] [=invalid argument=].
1. Let |enabled| be the result of [=getting a property=] named `"enabled"` from
    |parameters|.
1. If |enabled| is {{undefined}} or is not a boolean, return a [=error|WebDriver
    error=] with [=error code=] [=invalid argument=].
1. Set [=automation local testing mode enabled=] to |enabled|.
1. Return [=success=] with data `null`.

Note: Without this, [=aggregatable reports=] would be subject to delays, making
    testing difficult.

</div>

Shared Storage API monkey patches {#shared-storage-api-monkey-patches}
======================================================================

Issue(43): This should be moved to the Shared Storage spec.

Issue: Go through all monkey patches and ensure every definition (including)
    structures that is needed is exported.

<xmp class="idl">
partial interface SharedStorageWorkletGlobalScope {
  readonly attribute PrivateAggregation privateAggregation;
};

dictionary SharedStoragePrivateAggregationConfig {
  USVString aggregationCoordinatorOrigin;
  USVString contextId;
  [EnforceRange] unsigned long long filteringIdMaxBytes;
};

partial dictionary SharedStorageRunOperationMethodOptions {
  SharedStoragePrivateAggregationConfig privateAggregationConfig;
};
</xmp>

The {{SharedStorageWorkletGlobalScope/privateAggregation}} [=getter steps=] are
to [=get the privateAggregation=] given [=this=].

Add the following algorithm in the subsection
"<a href="https://wicg.github.io/shared-storage/#run-op">Run Operation
Methods</a>":

<div algorithm>
To <dfn>obtain the aggregation coordinator</dfn> given a
{{SharedStorageRunOperationMethodOptions}} |options|, perform the following
steps. They return an [=aggregation coordinator=], null or a {{DOMException}}:

1. If
    |options|["{{SharedStorageRunOperationMethodOptions/privateAggregationConfig}}"]
    does not [=map/exist=], return null.
1. If
    |options|["{{SharedStorageRunOperationMethodOptions/privateAggregationConfig}}"]["{{SharedStoragePrivateAggregationConfig/aggregationCoordinatorOrigin}}"]
    does not [=map/exist=], return null.
1. Let |url| be the result of running the [=URL parser=] on
    |options|["{{SharedStorageRunOperationMethodOptions/privateAggregationConfig}}"]["{{SharedStoragePrivateAggregationConfig/aggregationCoordinatorOrigin}}"].
1. If |url| is failure or null, return a new {{DOMException}} with name
    "`SyntaxError`".

    Issue: Consider throwing an error if the path is not empty.
1. Let |origin| be |url|'s [=url/origin=].
1. If the result of [=determining if an origin is an aggregation coordinator=]
    given |origin| is false, return a new {{DOMException}} with name
    "`DataError`".
1. Return |origin|.

</div>

<div algorithm>
To <dfn>obtain the pre-specified report parameters</dfn> given a
{{SharedStorageRunOperationMethodOptions}} |options| and a [=browsing context=]
|context|, perform the following steps. They return a [=pre-specified report
parameters=], null, or a {{DOMException}}:
1. If |options|["{{SharedStorageRunOperationMethodOptions/privateAggregationConfig}}"]
    does not [=map/exist=], return null.
1. Let |privateAggregationConfig| be
    |options|["{{SharedStorageRunOperationMethodOptions/privateAggregationConfig}}"].
1. Let |contextId| be null.
1. If |privateAggregationConfig|["{{SharedStoragePrivateAggregationConfig/contextId}}"]
    [=map/exists=], set |contextId| to
    |privateAggregationConfig|["{{SharedStoragePrivateAggregationConfig/contextId}}"].
1. If |contextId|'s [=string/length=] is greater than 64, return a new
    {{DOMException}} with name "`DataError`".
1. Let |filteringIdMaxBytes| be the [=default filtering ID max bytes=].
1. If |privateAggregationConfig|["{{SharedStoragePrivateAggregationConfig/filteringIdMaxBytes}}"]
    [=map/exists=], set |filteringIdMaxBytes| to
    |privateAggregationConfig|["{{SharedStoragePrivateAggregationConfig/filteringIdMaxBytes}}"].
1. If |filteringIdMaxBytes| is not [=set/contained=] in the [=valid filtering ID
    max bytes range=], return a new {{DOMException}} with name "`DataError`".
1. If |context|'s [=browsing context/fenced frame config instance=] is not null:
    1. If |filteringIdMaxBytes| is not the [=default filtering ID max bytes=] or
        |contextId| is not null, return a new {{DOMException}} with name
        "`DataError`".
1. Return a new [=pre-specified report parameters=] with the items:
    : [=pre-specified report parameters/context ID=]
    :: |contextId|
    : [=pre-specified report parameters/filtering ID max bytes=]
    :: |filteringIdMaxBytes|

</div>

The {{SharedStorageWorklet}}'s {{SharedStorageWorklet/run()}} method steps are
modified in four ways. First, add the following steps just after step 4
("[=Assert=]: <var ignore>window</var> is a [=Window=]"), renumbering later
steps as appropriate:
<div algorithm="shared-storage-run-monkey-patch-1">
5. Let |context| be <var ignore>window</var>'s [=Window/browsing context=].
1. If |context| is null, then return [=a promise rejected with=] a
    {{TypeError}}.
1. Let |preSpecifiedParams| be the result of [=obtaining the pre-specified
    report parameters=] given |options| and |context|.
1. If |preSpecifiedParams| is a {{DOMException}}, return [=a promise rejected
    with=] |preSpecifiedParams|.
1. Let |aggregationCoordinator| be the result of [=obtaining the aggregation
    coordinator=] given |options|.
1. If |aggregationCoordinator| is a {{DOMException}}, return [=a promise
    rejected with=] |aggregationCoordinator|.

</div>
Second, add the following steps in the nested scope just after "Let |operation|
be |operationMap|[|name|]." (renumbering later steps as appropriate):
<div algorithm="shared-storage-run-monkey-patch-2">
2. Let |batchingScope| be a new [=batching scope=].
1. Let <var ignore>debugScope</var> be a new [=debug scope=].
1. Let |privateAggregationTimeout| be null.
1. Let |isDeterministicReport| be false.
1. If |preSpecifiedParams| is not null:
    1. Set |isDeterministicReport| to the result of [=determining if a report
        should be sent deterministically=] given |preSpecifiedParams|.
    1. If |isDeterministicReport|:
        1. Set |privateAggregationTimeout| to the [=current wall time=] plus the
            [=deterministic operation timeout duration=].
    1. [=Set the pre-specified report parameters for a batching scope=] given
        |preSpecifiedParams| and |batchingScope|.
1. If |aggregationCoordinator| is not null, [=set the aggregation coordinator
    for a batching scope=] given |aggregationCoordinator| and |batchingScope|.

</div>

Third, add the following steps in the same nested scope just before the current
penultimate step ("If <var ignore>options</var>
[=map/contains=] <var ignore>data</var>", renumbering the last step as
appropriate):
<div algorithm="shared-storage-run-monkey-patch-3">
1. Let |hasRunPrivateAggregationCompletionTask| be false.
1. Let |privateAggregationCompletionTask| be an algorithm to perform the
    following steps:
    1. If |hasRunPrivateAggregationCompletionTask|, return.
    1. Set |hasRunPrivateAggregationCompletionTask| to true.
    1. [=Mark a debug scope complete=] given <var ignore>debugScope</var>.
    1. [=Process contributions for a batching scope=] given
        <var ignore>batchingScope</var>, <var ignore>outsideSettings</var>'
        [=environment settings object/origin=], "<code>shared-storage</code>"
        and |privateAggregationTimeout|.
1. If <var ignore>isDeterministicReport</var>>, run the following steps [=in
    parallel=]:
    1. Wait until |privateAggregationTimeout|.
    1. Run |privateAggregationCompletionTask|.

</div>

Finally, at the end of the same nested scope, add the following step:
<div algorithm="shared-storage-run-monkey-patch-4">
9. When the above [=call=] returns, perform the following steps:
    1. Run <var ignore>privateAggregationCompletionTask</var>.

</div>

The {{SharedStorageWorklet}}'s {{SharedStorageWorklet/selectURL()}} method steps
are modified in three ways. First, add the following steps just after step 6
("If <var ignore>context</var> is null..."), renumbering later steps:
<div algorithm="shared-storage-selecturl-monkey-patch-1">
7. Let |preSpecifiedParams| be the result of [=obtaining the pre-specified
    report parameters=] given |options| and <var ignore>context</var>.
1. If |preSpecifiedParams| is a {{DOMException}}, return [=a promise rejected
    with=] |preSpecifiedParams|.
1. Let |aggregationCoordinator| be the result of [=obtaining the aggregation
    coordinator=] given |options|.
1. If |aggregationCoordinator| is a {{DOMException}}, return [=a promise
    rejected with=] |aggregationCoordinator|.

</div>
Second, add the following steps in the nested scope just after "Let |operation|
be |operationMap|[|name|]." (renumbering later steps as appropriate):
<div algorithm="shared-storage-selecturl-monkey-patch-2">
2. Let |batchingScope| be a new [=batching scope=].
1. Let |debugScope| be a new [=debug scope=].
1. Let |privateAggregationTimeout| be null.
1. Let |hasRunPrivateAggregationCompletionTask| be false.
1. Let |privateAggregationCompletionTask| be an algorithm to perform the
    following steps:
    1. If |hasRunPrivateAggregationCompletionTask|, return.
    1. Set |hasRunPrivateAggregationCompletionTask| to true.
    1. [=Mark a debug scope complete=] given |debugScope|.
    1. [=Process contributions for a batching scope=] given
        |batchingScope|, <var ignore>outsideSettings</var>'
        [=environment settings object/origin=], "<code>shared-storage</code>"
        and |privateAggregationTimeout|.
1. If |aggregationCoordinator| is not null, [=set the aggregation coordinator
    for a batching scope=] given |aggregationCoordinator| and |batchingScope|.
1. If |preSpecifiedParams| is not null:
    1. Let |isDeterministicReport| be the result of [=determining if a report
        should be sent deterministically=] given |preSpecifiedParams|.
    1. If |isDeterministicReport|:
        1. Set |privateAggregationTimeout| to the [=current wall time=] plus the
            [=deterministic operation timeout duration=].
    1. [=Set the pre-specified report parameters for a batching scope=] given
        |preSpecifiedParams| and |batchingScope|.
    1. If |isDeterministicReport|, run the following steps [=in parallel=]:
        1. Wait until |privateAggregationTimeout|.
        1. Run |privateAggregationCompletionTask|.

</div>
Finally, at the end of the same nested scope, add the following steps:
<div algorithm="shared-storage-selecturl-monkey-patch-3">
13. Run <var ignore>privateAggregationCompletionTask</var>.

</div>

Issue: Once <a href="https://github.com/wicg/shared-storage/issues/88">
    shared-storage/88</a> is resolved, align the above monkey patches with how
    `keepAlive` is handled at operation completion.

The {{Worklet/addModule()}} steps are modified to add a new step just before
the final step ("Return <var ignore>promise</var>."), renumbering the last step
as appropriate:
<div algorithm="shared-storage-addmodule-monkey-patch">
7. If |this| is a {{SharedStorageWorklet}}, [=upon fulfillment=] of |promise| or
    [=upon rejection=] of |promise|, run the following steps:
    1. Let |globalScopes| be |this|'s [=Worklet/global scopes=].
    1. [=Assert=]: |globalScopes|' [=list/size=] equals 1.
    1. Let |privateAggregationObj| be |globalScopes|[0]'s
        {{SharedStorageWorkletGlobalScope/privateAggregation}}.
    1. Set |privateAggregationObj|'s [=PrivateAggregation/allowed to use=] to
        the result of determining whether [=this=]'s [=relevant global
        object=]'s [=associated document=] is [=allowed to use=] the
        "<code>[=private-aggregation=]</code>" [=policy-controlled feature=].

        Issue: Consider adding an early return here (and equivalently for
            Protected Audience) if the permissions policy check is made first.
    1. Set |privateAggregationObj|'s [=PrivateAggregation/scoping details=] to a
            new [=scoping details=] with the items:
        : [=scoping details/get batching scope steps=]
        :: An algorithm that returns the [=batching scope=] that is scheduled to
            be passed to [=process contributions for a batching scope=] when the
            call currently executing in |scope| returns.
        : [=scoping details/get debug scope steps=]
        :: An algorithm that returns the [=debug scope=] that is scheduled to be
            passed to [=mark a debug scope complete=] when the call currently
            executing in |scope| returns.

        Note: Multiple operation invocations can be in-progress at the same
        time, each with a different batching scope and debug scope. However,
        only one can be currently executing.

</div>

Issue: Once <a href="https://github.com/wicg/shared-storage/issues/89">
    shared-storage/89</a> is resolved, align the above monkey patch with how
    access to `sharedStorage` is prevented in
    {{SharedStorageWorkletGlobalScope}}s until {{Worklet/addModule()}}'s initial
    execution is complete.

Note: This extends Shared Storage's existing {{Worklet/addModule()}}
    <a href="https://wicg.github.io/shared-storage/#worklet-monkey-patch">
    monkey patch</a>.

[=Implementation-defined=] values {#shared-storage-implementation-defined-values}
---------------------------------------------------------------------------------

<dfn>Deterministic operation timeout duration</dfn> is a non-negative
[=duration=] that controls how long a Shared Storage operation may make Private
Aggregation contributions if it is triggering a deterministic report and,
equivalently, when that report should be sent after the operation begins.

Protected Audience API monkey patches {#protected-audience-api-monkey-patches}
==============================================================================

Issue(43): This should be moved to the Protected Audience spec, along with any
    other Protected Audience-specific details.

New WebIDL {#protected-audience-api-specific-webidl}
----------------------------------------------------

<xmp class="idl">
partial interface InterestGroupScriptRunnerGlobalScope {
  readonly attribute PrivateAggregation privateAggregation;
};

dictionary PASignalValue {
  required DOMString baseValue;
  double scale;
  (bigint or long) offset;
};

dictionary PAExtendedHistogramContribution {
  required (PASignalValue or bigint) bucket;
  required (PASignalValue or long) value;
  bigint filteringId = 0;
};

[Exposed=InterestGroupScriptRunnerGlobalScope, SecureContext]
partial interface PrivateAggregation {
  undefined contributeToHistogramOnEvent(
      DOMString event, PAExtendedHistogramContribution contribution);
};

dictionary AuctionReportBuyersConfig {
  required bigint bucket;
  required double scale;
};

dictionary AuctionReportBuyerDebugModeConfig {
  boolean enabled = false;

  // Must only be provided if `enabled` is true.
  bigint? debugKey;
};

partial dictionary AuctionAdConfig {
  sequence<bigint> auctionReportBuyerKeys;
  record<DOMString, AuctionReportBuyersConfig> auctionReportBuyers;
  AuctionReportBuyerDebugModeConfig auctionReportBuyerDebugModeConfig;
};
</xmp>

Note: `requiredSellerCapabilities` is defined in the <a
    href="https://wicg.github.io/turtledove/#dictdef-auctionadconfig">Protected
    Audience spec</a>.

Issue: Do we want to align naming with implementation?

The {{InterestGroupScriptRunnerGlobalScope/privateAggregation}} [=getter steps=]
are to [=get the privateAggregation=] given [=this=].

<div algorithm>
The <dfn method for="PrivateAggregation">contributeToHistogramOnEvent(DOMString
event, PAExtendedHistogramContribution contribution)</dfn> method steps are:
1. Let |scopingDetails| be [=this=]'s [=PrivateAggregation/scoping details=].
1. If |event| [=string/starts with=] "`reserved.`" and « "`reserved.always`",
    "`reserved.loss`", "`reserved.win`" » does not [=list/contain=] |event|,
    return.

    Note: No error is thrown to allow forward compatibility if additional
        reserved event types are added later.
1. Let |bucket| be |contribution|["{{PAExtendedHistogramContribution/bucket}}"].
1. If |bucket| is a {{PASignalValue}}:
    1. If |bucket|["{{PASignalValue/baseValue}}"] is not a valid [=signal base
        value=], [=exception/throw=] a {{TypeError}}.
    1. If |bucket|["{{PASignalValue/offset}}"] is not a {{bigint}}, [=exception/
        throw=] a {{TypeError}}.
1. Otherwise, if |contribution|["{{PAExtendedHistogramContribution/bucket}}"] is
    not [=set/contained=] in [=the exclusive range|the range=] 0 to
    2<sup>128</sup>, exclusive, [=exception/throw=] a {{TypeError}}.

    Issue: Make the error type consistent with
        {{PrivateAggregation/contributeToHistogram(contribution)}}.
1. Let |value| be |contribution|["{{PAExtendedHistogramContribution/value}}"].
1. If |value| is a {{PASignalValue}}:
    1. If |value|["{{PASignalValue/baseValue}}"] is not a valid [=signal base
        value=], [=exception/throw=] a {{TypeError}}.
    1. If |value|["{{PASignalValue/offset}}"] is a {{bigint}}, [=exception/
        throw=] a {{TypeError}}.
1. Otherwise, if |contribution|["{{PAExtendedHistogramContribution/value}}"] is
    negative, [=exception/throw=] a {{TypeError}}.
1. If |contribution|["{{PAExtendedHistogramContribution/filteringId}}"] is
    not [=set/contained=] in [=the exclusive range|the range=] 0 to
    256<sup>[=default filtering ID max bytes=]</sup>, exclusive, [=exception/
    throw=] a {{TypeError}}.

    Issue: Make the error types on validation issues here and above consistent
        with {{PrivateAggregation/contributeToHistogram(contribution)}}.

    Note: It is not currently possible to set a non-default filtering ID max
        bytes for Protected Audience.
1. Let |batchingScope| be null.
1. If |event| [=string/starts with=] "`reserved.`", set |batchingScope| to the
    result of running |scopingDetails|' [=scoping details/get batching scope
    steps=].

    Note: Each non-reserved |event| will have a different [=batching scope=]
        that is created later.
1. Let |entry| be a new [=on event contribution cache entry=] with the items:
    : [=on event contribution cache entry/contribution=]
    :: |contribution|
    : [=on event contribution cache entry/batching scope=]
    :: |batchingScope|
    : [=on event contribution cache entry/debug scope=]
    :: The result of running |scopingDetails|' [=scoping details/get debug scope
        steps=].
    : [=on event contribution cache entry/worklet function=]
    :: The [=worklet function=] that is currently being executed.

1. Let |global| be [=this=]'s [=relevant global object=].
1. Let |auctionConfig| be |global|'s
    [=InterestGroupScriptRunnerGlobalScope/auction config=].
1. Let |ig| be the result of [=maybe obtain an interest group|maybe obtaining an
    interest group=] given |global|.
1. Let |cacheMap| be |auctionConfig|'s [=auction config/per-bid or seller on
    event contribution cache=].
1. If |cacheMap|[|ig|] does not [=map/exist=], [=map/set=] |cacheMap|[|ig|] to
    a new [=on event contribution cache=].
1. Let |onEventContributionCache| be |cacheMap|[|ig|].
1. If |onEventContributionCache|[|event|] does not [=map/exist=], set
    |onEventContributionCache|[|event|] to a new [=list=].
1. [=list/Append=] |entry| to |onEventContributionCache|[|event|].

Issue: Ensure errors are of an appropriate type, e.g. {{InvalidAccessError}} is
    deprecated.

Issue(44): Consider accepting an array of contributions.

</div>

WebIDL modifications {#protected-audience-api-webidl-modifications}
-------------------------------------------------------------------

The {{AuctionAdConfig}} and {{AuctionAdInterestGroup}} dictionaries are
modified to add a new field:
<xmp class="idl">
dictionary ProtectedAudiencePrivateAggregationConfig {
  USVString aggregationCoordinatorOrigin;
};

partial dictionary AuctionAdConfig {
  ProtectedAudiencePrivateAggregationConfig privateAggregationConfig;
};

partial dictionary AuctionAdInterestGroup {
  ProtectedAudiencePrivateAggregationConfig privateAggregationConfig;
};
</xmp>

Note: `sellerCapabilities` is defined in the <a
    href="https://wicg.github.io/turtledove#dictdef-generatebidinterestgroup">Protected
    Audience spec</a>

Structures {#protected-audience-api-specific-structures}
--------------------------------------------------------

<h4 id="extending-auction-config">Extending auction config</h4>

Extend the <a spec="turtledove">auction config</a> [=struct=] to add new fields:
<dl dfn-for="auction config">
: <dfn>per-bid or seller on event contribution cache</dfn>
:: A [=map=] from [=interest group=] or null to a [=on event contribution
    cache=].

    Note: a null key represents the seller.
: <dfn>batching scope map</dfn>
:: A [=map=] from a [=tuple=] consisting of an <dfn ignore>origin</dfn> (an
    [=origin=]) and a <dfn ignore>coordinator</dfn> (an [=aggregation
    coordinator=]) to a [=batching scope=].

    Note: Does not include [=batching scopes=] for contributions conditional on
        non-reserved events.
: <dfn>permissions policy state</dfn>
:: A [=permissions policy state=].
: <dfn>seller Private Aggregation coordinator</dfn>
:: An [=aggregation coordinator=]. Defaults to the [=default aggregation
    coordinator=].
: <dfn>auction report buyer keys</dfn>
:: A [=map=] from buyer [=origins=] to {{bigint}}s.
: <dfn>auction report buyers</dfn>
:: A [=map=] from [=strings=] to {{AuctionReportBuyersConfig}}s.
: <dfn>auction report buyer debug details</dfn>
:: A [=debug details=].

    Issue: Consider replacing the strings above with specific enum types.

</dl>

<h4 id="extending-interest-group">Extending interest group</h4>

Extend the <a spec="turtledove">interest group</a> [=struct=] to add a new
field:
<dl dfn-for="interest group">
: <dfn>Private Aggregation coordinator</dfn>
:: An [=aggregation coordinator=] or null.

    Note: a null value specifies the default coordinator.

</dl>

<br/>
Add the following definitions in a new subsection at the end of
<a href="https://wicg.github.io/turtledove/#structures">Structures</a>,
renumbered appropriately.

<h4 dfn-type=dfn>Permissions policy state</h4>
A permissions policy state is a [=struct=] with the following items:
<dl dfn-for="permissions policy state">
: <dfn>private aggregation enabled</dfn>
:: A [=boolean=] (default false)

</dl>

<h4 dfn-type=dfn>Signal base value</h4>
A signal base value is one of the following:
<dl dfn-for="signal base value">
: "<dfn><code>winning-bid</code></dfn>"
:: The numeric value is the bid value of the winning bid.
: "<dfn><code>highest-scoring-other-bid</code></dfn>"
:: The numeric value is the bid value of the highest scoring bid that did not
    win.
: "<dfn><code>script-run-time</code></dfn>"
:: The numeric value is the number of milliseconds of CPU time the calling
    function (e.g. `generateBid()`) took to run.
: "<dfn><code>signals-fetch-time</code></dfn>"
:: The numeric value is the number of milliseconds it took for the trusted
    bidding or scoring signals fetch to complete, when called from
    `generateBid()` or `scoreAd()`, respectively.

    Issue: Can this value be used in `reportWin()` or `reportResult()`?
: "<dfn><code>bid-reject-reason</code></dfn>"
:: The numeric value is an integer representing the reason a bid was rejected.

    Note: this mapping to an integer is defined in [=determine a signal's
        numeric value=].

</dl>

<h4 dfn-type=dfn>Worklet function</h4>
A worklet function is one of the following:
<dl dfn-for="worklet function">
: "<dfn><code>generate-bid</code></dfn>"
:: The `generateBid()` function.
: "<dfn><code>score-ad</code></dfn>"
:: The `scoreAd()` function.
: "<dfn><code>report-result</code></dfn>"
:: The `reportResult()` function.
: "<dfn><code>report-win</code></dfn>"
:: The `reportWin()` function.

</dl>

<h4 dfn-type=dfn>On event contribution cache entry</h4>
An on event contribution cache entry is a [=struct=] with the following items:
<dl dfn-for="on event contribution cache entry">
: <dfn>contribution</dfn>
:: A {{PAExtendedHistogramContribution}}
: <dfn>batching scope</dfn>
:: A [=batching scope=] or null
: <dfn>debug scope</dfn>
:: A [=debug scope=]
: <dfn>debug details</dfn>
:: A [=debug details=] or null (default null)
: <dfn>worklet function</dfn>
:: A [=worklet function=]

</dl>

<h4 dfn-type=dfn>On event contribution cache</h4>
An on event contribution cache is a [=map=] from [=string=] to a [=list=] of
[=on event contribution cache entries=].

<h4 id="extending-interestgroupscriptrunnerglobalscope">Extending
InterestGroupScriptRunnerGlobalScope</h4>

Extend the <a href="https://wicg.github.io/turtledove/#global-scopes">global
scopes</a> subsection to add:

Each {{InterestGroupScriptRunnerGlobalScope}} has an:
<dl>
: <dfn for="InterestGroupScriptRunnerGlobalScope">auction config</dfn>
:: An <a spec="turtledove">auction config</a>

</dl>

<h4 id="extending-interestgroupreportingscriptrunnerglobalscope">Extending
InterestGroupReportingScriptRunnerGlobalScope</h4>

Extend the <a
href="https://wicg.github.io/turtledove/#reporting-global-scope">InterestGroupReportingScriptRunnerGlobalScope</a>
subsection to add an extra field to the end of the list beginning
"Each {{InterestGroupReportingScriptRunnerGlobalScope}} has a":
<dl>
: <dfn for="InterestGroupReportingScriptRunnerGlobalScope">interest group</dfn>
:: Null or an [=interest group=]. Null for seller reporting
    (i.e. `reportResult()`).

</dl>

Algorithm modifications {#protected-audience-api-algorithm-modifications}
-------------------------------------------------------------------------

The {{Navigator/joinAdInterestGroup()}} method steps are modified to add the
following steps at the end of the scope nested under step 5 ("Validate the given
<var ignore>group</var> and ..."):
<div algorithm="protected-audience-joinadig-monkey-patch">
17. If |group|["{{AuctionAdInterestGroup/privateAggregationConfig}}"]
    [=map/exists=]:
    1. Let |aggregationCoordinator| be the result of [=obtaining the Private
        Aggregation coordinator=] given
        |group|["{{AuctionAdInterestGroup/privateAggregationConfig}}"].
    1. If |aggregationCoordinator| is a {{DOMException}}, then
        [=exception/throw=] |aggregationCoordinator|.
    1. Set <var ignore>interestGroup</var>'s [=interest group/Private
        Aggregation coordinator=] to |aggregationCoordinator|.

</div>

The {{Navigator/runAdAuction()}} method steps are modified to add the
following step just after step 5 ("If <var ignore>auctionConfig</var> is a
failure, then..."), renumbering the later steps as appropriate:
<div algorithm="protected-audience-runadauction-monkey-patch">
6. Set <var ignore>auctionConfig</var>'s [=auction config/permissions policy
    state=] to a new [=permissions policy state=] with the items:
    : [=permissions policy state/private aggregation enabled=]
    :: The result of determining whether <var ignore>global</var>'s [=associated
        Document=] is [=allowed to use=] the
        "<code>[=private-aggregation=]</code>" [=policy-controlled feature=].

</div>

The <a spec="turtledove">validate and convert auction ad config</a> steps are
modified to add the following steps just before the last step ("Return
<var ignore>auctionConfig</var>"), renumbering the later step as appropriate:
<div algorithm="protected-audience-validate-config-monkey-patch">
31. If |config|["{{AuctionAdConfig/auctionReportBuyerKeys}}"] [=map/exists=]:
    1. Let |interestGroupBuyers| be |auctionConfig|'s <a spec="turtledove"
        for="auction config">interest group buyers</a>.
    1. If |interestGroupBuyers| is null, set |interestGroupBuyers| to a new
        [=list=].
    1. [=list/For each=] |index| of [=the exclusive range|the range=] 0 to
        |config|["{{AuctionAdConfig/auctionReportBuyerKeys}}"]'s [=list/size=],
        exclusive:
        1. Let |key| be
            |config|["{{AuctionAdConfig/auctionReportBuyerKeys}}"][|index|].
        1. If |key| is not [=set/contained=] in [=the exclusive range|the
            range=] 0 to 2<sup>128</sup>, exclusive, [=exception/throw=] a
            {{TypeError}}.
        1. If |index| is equal to or greater than |interestGroupBuyers|' [=list/
            size=], [=iteration/continue=].

            Note: [=iteration/Continue=] is used (instead of [=iteration/
                break=]) to match validation logic for all given buyer keys.
        1. Let |origin| be |interestGroupBuyers|[|index|].
        1. [=map/Set=] |auctionConfig|'s [=auction config/auction report buyer
            keys=][|origin|] to |key|.

            Issue: Check behavior when an origin is repeated in
                {{AuctionAdConfig/interestGroupBuyers}}.
1. If |config|["{{AuctionAdConfig/auctionReportBuyers}}"] [=map/exists=]:
    1. [=map/For each=] |reportType| → |reportBuyerConfig| of
        |config|["{{AuctionAdConfig/auctionReportBuyers}}"]:
        1. If « "`interestGroupCount`", "`bidCount`",
            "`totalGenerateBidLatency`", "`totalSignalsFetchLatency`" » does not
            [=list/contain=] |reportType|, [=iteration/continue=].

            Note: No error is thrown to allow forward compatibility if
                additional report types are added later.

            Issue: Should these strings be dash delimited?

        1. If |reportBuyerConfig|["{{AuctionReportBuyersConfig/bucket}}"] is not
            [=set/contained=] in [=the exclusive range|the range=] 0 to
            2<sup>128</sup>, exclusive, [=exception/throw=] a {{TypeError}}.

            Issue: Consider validating the case where the bucket used (after
                summing) is too large. Currently, the implementation appears to
                overflow. See <a
                href="https://github.com/WICG/turtledove/issues/1040">
                protected-audience/1040</a>.
        1. [=map/Set=] |auctionConfig|'s [=auction config/auction report
            buyers=][|reportType|] to |reportBuyerConfig|.

1. Set |auctionConfig|'s [=auction config/auction report buyer debug details=]
    to a new [=debug details=].
1. If |config|["{{AuctionAdConfig/auctionReportBuyerDebugModeConfig}}"]
    [=map/exists=]:
    1. Let |debugModeConfig| be
        |config|["{{AuctionAdConfig/auctionReportBuyerDebugModeConfig}}"].
    1. Let |enabled| be
        |debugModeConfig|["{{AuctionReportBuyerDebugModeConfig/enabled}}"].
    1. Let |debugKey| be
        |debugModeConfig|["{{AuctionReportBuyerDebugModeConfig/debugKey}}"].
    1. If |debugKey| is not null:
        1. If |debugKey| is not [=set/contained=] in [=the exclusive range|the
            range=] 0 to 2<sup>64</sup>, exclusive, [=exception/throw=] a
            {{TypeError}}.
        1. If |enabled| is false, [=exception/throw=] a {{TypeError}}.
    1. Set |auctionConfig|'s [=auction config/auction report buyer debug
        details=] to a new [=debug details=] with the items:
        : [=debug details/enabled=]
        :: |enabled|
        : [=debug details/key=]
        :: |debugKey|
1. If |config|["{{AuctionAdConfig/privateAggregationConfig}}"] [=map/exists=]:
    1. Let |aggregationCoordinator| be the result of [=obtaining the Private
        Aggregation coordinator=] given
        |config|["{{AuctionAdConfig/privateAggregationConfig}}"].
    1. If |aggregationCoordinator| is a {{DOMException}}, return failure.
    1. Set <var ignore>auctionConfig</var>'s [=auction config/seller Private
        Aggregation coordinator=] to |aggregationCoordinator|.

Issue: Make all map indexing links (throughout the spec) where possible, i.e.
    matching this section.

</div>

The <a spec="turtledove">generate and score bids</a> algorithm is modified by
inserting the following step before each of the two "Return <var ignore>leadingBidInfo</var>'s
<a spec="turtledove" for="leading bid info">leading bid</a>" steps (one in a
nested scope), renumbering this and later steps as necessary.
<div algorithm="protected-audience-generate-and-score-bids-monkey-patch">
1. [=Process the Private Aggregation contributions for an auction=] given
    <var ignore>auctionConfig</var> and <var ignore>leadingBidInfo</var>.

</div>

The <a spec="turtledove">evaluate a script</a> steps are modified in two ways.
First, we add the following steps after step 11 ("If
<var ignore>evaluationStatus</var> is an [=ECMAScript/abrupt completion=]..."),
renumbering later steps as appropriate:
<div algorithm="protected-audience-evaluate-a-script-monkey-patch">
12. Set |global|'s {{InterestGroupScriptRunnerGlobalScope/privateAggregation}}'s
    [=PrivateAggregation/allowed to use=] to |auctionConfig|'s [=auction config/
    permissions policy state=]'s [=permissions policy state/private aggregation
    enabled=].
1. Let |debugScope| be a new [=debug scope=].
1. Set |global|'s {{InterestGroupScriptRunnerGlobalScope/privateAggregation}}'s
    [=PrivateAggregation/scoping details=] to a new [=scoping details=] with the
    [=struct/items=]:
    : [=scoping details/get batching scope steps=]
    :: An algorithm that performs the following steps:
        1. Let |origin| be |realm|'s [=realm/settings object=]'s [=environment
            settings object/origin=].
        1. Let |ig| be the result of [=maybe obtain an interest group|maybe
            obtaining an interest group=] given |realm|'s [=realm/global
            object=].
        1. Let |aggregationCoordinator| be null.
        1. If |ig| is not null, set |aggregationCoordinator| to |ig|'s
            [=interest group/Private Aggregation coordinator=].
        1. Otherwise, set |aggregationCoordinator| to |auctionConfig|'s
            [=auction config/seller Private Aggregation coordinator=].
        1. If |aggregationCoordinator| is null, set |aggregationCoordinator| to
            the [=default aggregation coordinator=].
        1. Return the result of running [=get or create a batching scope=] given
            |origin|, |aggregationCoordinator| and |auctionConfig|.
    : [=scoping details/get debug scope steps=]
    :: An algorithm that returns |debugScope|.

</div>

Issue: Once <a href="https://github.com/wicg/turtledove/issues/615">
    protected-audience/615</a> is resolved, align the above monkey patch with
    how access to other functions is prevented in
    {{InterestGroupScriptRunnerGlobalScope}}s until the script's initial
    execution is complete.

Second, in the nested scope of the last step, we insert a new step just after
the step labelled "Clean up after script", renumbering the later step as
appropriate:
<div algorithm="protected-audience-evaluate-a-script-monkey-patch-2">
2. Let |debugDetails| be the result of [=get a debug details=] given
    |debugScope|.
1. Let |ig| be the result of [=maybe obtain an interest group|maybe obtaining an
    interest group=] given <var ignore>global</var>.
1. Let |onEventContributionCache| be <var ignore>auctionConfig</var>'s [=auction
    config/per-bid or seller on event contribution cache=][|ig|].
1. [=map/iterate|For each=] <var ignore>event</var> → |entries| of
    |onEventContributionCache|:
    1. [=list/iterate|For each=] |onEventEntry| of |entries|:
        1. If |onEventEntry|'s [=on event contribution cache entry/debug scope=]
            is |debugScope|, set |onEventEntry|'s [=on event contribution cache
            entry/debug details=] to |debugDetails|.
1. [=Mark a debug scope complete=] given |debugScope|.

</div>

The <a spec="turtledove">evaluate a bidding script</a> steps are modified in the
following two ways. First, we add a new parameter <a spec="turtledove">auction
config</a> |auctionConfig|.

Note: This algorithm already takes an [=interest group=] parameter |ig|.

Second, we add the following step after step 6 ("Set <var ignore>global</var>'s
<a spec="turtledove" for="InterestGroupBiddingScriptRunnerGlobalScope">interest
group</a> to <var ignore>ig</var>"), renumbering later steps as appropriate:
<div algorithm="protected-audience-evaluate-a-bidding-script-monkey-patch">
7. Set <var ignore>global</var>'s [=InterestGroupScriptRunnerGlobalScope/auction
    config=] to <var ignore>auctionConfig</var>.

</div>

The <a spec="turtledove">evaluate a scoring script</a> steps are modified in the
following two ways. First, we add a new parameter <a spec="turtledove">auction
config</a> |auctionConfig|.

Second, we add the following step after step 1 ("Let |global| be a new
{{InterestGroupScoringScriptRunnerGlobalScope}}."),
renumbering the later step as appropriate:
<div algorithm="protected-audience-evaluate-a-scoring-script-monkey-patch">
2. Set <var ignore>global</var>'s [=InterestGroupScriptRunnerGlobalScope/auction
    config=] to <var ignore>auctionConfig</var>.

</div>

The <a spec="turtledove">evaluate a reporting script</a> steps are modified in
the following two ways. First, we add two new parameters: an
<a spec="turtledove">auction config</a> |auctionConfig| and an [=interest
group=] or null |ig|.

Second, we add the following step after step 1 ("Let |global| be a new
{{InterestGroupReportingScriptRunnerGlobalScope}}."),
renumbering the later step as appropriate:
<div algorithm="protected-audience-evaluate-a-reporting-script-monkey-patch">
2. Set |global|'s [=InterestGroupScriptRunnerGlobalScope/auction config=] to
    <var ignore>auctionConfig</var>.
1. Set |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/interest
    group=] to <var ignore>ig</var>.

</div>

Then, we modify the invocations of the above algorithms to plumb the new
parameters in:

The <a spec="turtledove">generate potentially multiple bids</a> algorithm is
modified to add a new <a spec="turtledove">auction config</a> parameter
|auctionConfig|. Additionally, its last step is modified by adding the argument
|auctionConfig| to the invocation of <a spec="turtledove">evaluating a bidding
script</a>. Further, the <a spec="turtledove">generate and score bids</a>
algorithm is modified by adding the argument |auctionConfig| to both invocations
of <a spec="turtledove">generate potentially multiple bids</a>.

The <a spec="turtledove">score and rank a bid</a> algorithm is modified by
adding the argument |auctionConfig| to the invocation of
<a spec="turtledove">evaluating a scoring script</a>.

The <a spec="turtledove">report result</a> algorithm is modified by passing in
the arguments |auctionConfig| and null to the invocation of
<a spec="turtledove">evaluate a reporting script</a>.

The <a spec="turtledove">report win</a> algorithm is modified by passing in
the arguments |auctionConfig| and <var ignore>winner</var>'s
<a spec="turtledove" for="generated bid">interest group</a> to the invocation of
<a spec="turtledove">evaluate a reporting script</a>.

The <a spec="turtledove" for="interest group">estimated size</a> of an interest
group algorithm is modified to add the following line at the end of the sum:
<div algorithm="protected-audience-estimated-size-monkey-patch">
16. The [=string/length=] of the [=serialization of an origin|serialization=] of
    <var ignore>ig</var>'s [=interest group/Private Aggregation coordinator=] if
    the field is not null.

</div>

The <a spec="turtledove" lt="interest group update">update interest groups</a>
steps are modified to add the following case at the end of the "Switch on
<var ignore>key</var>" step.
<div algorithm="protected-audience-update-interest-groups-monkey-patch">
<dl class="switch">
: "`privateAggregationConfig`"
::
    1. If |value| is not a [=map=] whose [=map/keys=] are [=strings=], jump to
        the step labeled Abort update.
    1. If |value|["`aggregationCoordinatorOrigin`"] [=map/exists=]:
        1. If |value|["`aggregationCoordinatorOrigin`"] is not a [=string=],
            jump to the step labeled Abort update.
        1. Let |aggregationCoordinator| be the result of [=obtain the Private
            Aggregation coordinator from a string|obtaining the Private
            Aggregation coordinator=] given
            |value|["`aggregationCoordinatorOrigin`"].
        1. If |aggregationCoordinator| is a {{DOMException}}, jump to the step
            labeled Abort update.
        1. Otherwise, set <var ignore>ig</var>'s [=interest group/Private
            Aggregation coordinator=] to |aggregationCoordinator|.

</dl>

</div>

New algorithms {#protected-audience-api-specific-new-algorithms}
----------------------------------------------------------------

Add the following definitions:

<div algorithm>
To <dfn>process the Private Aggregation contributions for an auction</dfn> given
an <a spec="turtledove">auction config</a> |auctionConfig| and a
<a spec="turtledove">leading bid info</a> |leadingBidInfo|:
1. Let |winnerOrigin| be null.
1. If |leadingBidInfo|'s <a spec="turtledove" for="leading bid info">leading
    bid</a> is not null, set |winnerOrigin| to |leadingBidInfo|'s
    <a spec="turtledove" for="leading bid info">leading bid</a>'s
    <a spec="turtledove" for="generated bid">interest group</a>'s
    <a spec="turtledove" for="interest group">owner</a>.
1. [=map/iterate|For each=] |ig| → |onEventContributionCache| of
    |auctionConfig|'s [=auction config/per-bid or seller on event contribution
    cache=]:
    1. Let |origin| be null.
    1. If |ig| is null, set |origin| to |auctionConfig|'s
        <a spec="turtledove" for="auction config">seller</a>.
    1. Otherwise, set |origin| to |ig|'s
        <a spec="turtledove" for="interest group">owner</a>.
    1. [=map/iterate|For each=] |event| → |entries| of
        |onEventContributionCache|:
        1. If |event| is "`reserved.win`" or does not [=string/start with=]
            "`reserved.`":
            1. If |origin| is not |winnerOrigin|, return.
        1. If |event| is "`reserved.loss`" and |origin| is |winnerOrigin|,
            return.
        1. [=list/iterate|For each=] |onEventEntry| of |entries|:
            1. Let |filledInContribution| be the result of [=filling in the
                contribution=] given |onEventEntry|'s [=on event contribution
                cache entry/contribution=] and |leadingBidInfo|.

                Issue: Once
                    <a href="https://github.com/WICG/turtledove/issues/627">
                    protected-audience/627</a> is resolved, align 'filling in'
                    logic with `forDebuggingOnly`.
            1. If |event| does not [=string/start with=] "`reserved.`":
                1. Store |event|, |filledInContribution|, |onEventEntry|'s [=on
                    event contribution cache entry/debug details=] in the
                    {{FencedFrameConfig}} as appropriate.

                    Note: Each non-reserved |event| will have a different
                        [=batching scope=].

                    Issue: Once
                        <a href="https://github.com/WICG/turtledove/issues/616">
                        protected-audience/616</a> and any successors are
                        landed, align integration and fill in fenced frame's
                        <a spec="fenced-frame">report a private aggregation
                        event</a>.
                1. [=iteration/Continue=].
            1. Let |entry| be a new [=contribution cache entry=] with the items:
                : [=contribution cache entry/contribution=]
                :: |filledInContribution|
                : [=contribution cache entry/batching scope=]
                :: |onEventEntry|'s [=on event contribution cache entry/batching
                    scope=]
                : [=contribution cache entry/debug scope=]
                :: |onEventEntry|'s [=on event contribution cache entry/debug
                    scope=]
                : [=contribution cache entry/debug details=]
                :: |onEventEntry|'s [=on event contribution cache entry/debug
                    details=]
            1. [=Append an entry to the contribution cache|Append=] |entry| to
                the [=contribution cache=].
1. Let |sellerBatchingScope| be the result of [=get or create a batching
    scope|getting or creating a batching scope=] given |auctionConfig|'s <a
    spec="turtledove" for="auction config">seller</a>, |auctionConfig|'s
    [=auction config/seller Private Aggregation coordinator=], and
    |auctionConfig|.
1. Let |auctionReportBuyersDebugScope| be a new [=debug scope=].
1. [=map/For each=] |reportType| → |reportBuyerConfig| of |auctionConfig|'s
    [=auction config/auction report buyers=]:
    1. [=map/For each=] |buyerOrigin| → |buyerOffset| of |auctionConfig|'s
        [=auction config/auction report buyer keys=]:
        1. Let |bucket| be the sum of |buyerOffset| and |reportBuyerConfig|'s
            {{AuctionReportBuyersConfig/bucket}}.

            Issue: Handle overflow here or in validation. See <a
                href="https://github.com/WICG/turtledove/issues/1040">
                protected-audience/1040</a>.
        1. Let |value| be the result (a {{double}}) of switching on
            |reportType|:
            <dl class="switch">
            : "`interestGroupCount`"
            :: The number of interest groups in the [=user agent=]'s <a
                spec="turtledove">interest group set</a> whose <a
                spec="turtledove" for="interest group">owner</a> is
                |buyerOrigin|.
            : "`bidCount`"
            :: The number of valid bids generated by interest groups whose <a
                spec="turtledove" for="interest group">owner</a> is
                |buyerOrigin|.
            : "`totalGenerateBidLatency`"
            :: The sum of execution time in milliseconds for all `generateBid()`
                calls in the auction for interest groups whose <a
                spec="turtledove" for="interest group">owner</a> is
                |buyerOrigin|.
            : "`totalSignalsFetchLatency`"
            :: The total time spent fetching trusted buyer signals in
                milliseconds, or 0 if the interest group didn't fetch any
                trusted signals.
            : None of the above values
            :: [=Assert=]: false

                Note: This enum value is validated in <a
                    spec="turtledove">validate and convert auction ad
                    config</a>.

            </dl>

            Issue: More formally spec the values here.
        1. Set |value| to the result of multiplying |reportBuyerConfig|'s
            {{AuctionReportBuyersConfig/scale}} with |value|.
        1. Set |value| to the maximum of 0.0 and |value|.
        1. Set |value| to the result of converting |value| to an integer by
            truncating its fractional part.
        1. Set |value| to the minimum of |value| and 2<sup>31</sup>−1.
        1. Let |contribution| be a new {{PAHistogramContribution}} with the
            items:
            : {{PAHistogramContribution/bucket}}
            :: |bucket|
            : {{PAHistogramContribution/value}}
            :: |value|
            : {{PAHistogramContribution/filteringId}}
            :: 0

              Issue: Consider allowing the filtering ID to be set here.
        1. [=map/For each=] |ig| of the [=user agent=]'s <a spec="turtledove">
            interest group set</a> whose
            <a spec="turtledove" for="interest group">owner</a> is
            |buyerOrigin|:
            1. If seller capabilities don't allow this reporting, [=iteration/
                continue=].

                Issue: Align behavior with seller capabilities handling once <a
                    href="https://github.com/WICG/turtledove/issues/966">
                    protected-audience/966</a> is resolved.
            1. Let |entry| be a new [=contribution cache entry=] with the items:
                : [=contribution cache entry/contribution=]
                :: |contribution|
                : [=contribution cache entry/batching scope=]
                :: |sellerBatchingScope|
                : [=contribution cache entry/debug scope=]
                :: |auctionReportBuyersDebugScope|
            1. [=Append an entry to the contribution cache|Append=] |entry| to
                the [=contribution cache=].
1. [=Mark a debug scope complete=] given |auctionReportBuyersDebugScope| and
    |auctionConfig|'s [=auction config/auction report buyer debug details=].
1. [=map/For each=] (|origin|, <var ignore>aggregationCoordinator</var>) →
    |batchingScope| of |auctionConfig|'s [=auction config/batching scope map=]:
    1. [=Process contributions for a batching scope=] given |batchingScope|,
        |origin|, "<code>protected-audience</code>" and null.

Issue: Verify interaction with component auctions.

Issue: Use `[=map/For each=]` where possible.
</div>

<div algorithm>
To <dfn>get or create a batching scope</dfn> given an [=origin=] |origin|, an
[=aggregation coordinator=] |aggregationCoordinator| and an <a
spec="turtledove">auction config</a> |auctionConfig|, perform the following
steps. They return a [=batching scope=].
1. Let |batchingScopeMap| be |auctionConfig|'s [=auction config/batching scope
    map=].
1. Let |tuple| be (|origin|, |aggregationCoordinator|).
1. If |batchingScopeMap|[|tuple|] does not [=map/exist=]:
    1. Set |batchingScopeMap|[|tuple|] to a new [=batching scope=].
    1. If |aggregationCoordinator| is not null, [=set the aggregation
        coordinator for a batching scope=] given |aggregationCoordinator| and
        |batchingScopeMap|[|tuple|].
1. Return |batchingScopeMap|[|tuple|].

</div>

<div algorithm>
To <dfn>fill in the contribution</dfn> given a
{{PAExtendedHistogramContribution}} |contribution| and a
<a spec="turtledove">leading bid info</a> |leadingBidInfo|, perform the
following steps. They return a {{PAHistogramContribution}}.
1. Let |bucket| be |contribution|["{{PAExtendedHistogramContribution/bucket}}"].
1. If |bucket| is a {{PASignalValue}}, set |bucket| to the result of [=filling
    in the signal value=] given |bucket|, 2<sup>128</sup>−1 and |leadingBidInfo|.
1. Let |value| be |contribution|["{{PAExtendedHistogramContribution/value}}"].
1. If |value| is a {{PASignalValue}}, set |value| to the result of [=filling in
    the signal value=] given |value|, 2<sup>31</sup>−1 and |leadingBidInfo|.
1. Let |filledInContribution| be a new {{PAHistogramContribution}} with the
    items:
    : {{PAHistogramContribution/bucket}}
    :: |bucket|
    : {{PAHistogramContribution/value}}
    :: |value|
    : {{PAHistogramContribution/filteringId}}
    :: |contribution|["{{PAExtendedHistogramContribution/filteringId}}"]
1. Return |filledInContribution|.

</div>

<div algorithm>
To <dfn>fill in the signal value</dfn> given a {{PASignalValue}} |value|, an
integer |maxAllowed| and a <a spec="turtledove">leading bid info</a>
|leadingBidInfo|, perform the following steps. They return an integer.
1. [=Assert=]: |value|["{{PASignalValue/baseValue}}"] is a valid [=signal base
    value=].
1. Let |returnValue| be the result of [=determining a signal's numeric value=]
    given |value|["{{PASignalValue/baseValue}}"] and |leadingBidInfo|.
1. If |value|["{{PASignalValue/scale}}"] [=map/exists=], set |returnValue| to
    the result of multiplying |value|["{{PASignalValue/scale}}"] with
    |returnValue|.
1. Set |returnValue| to the result of converting |returnValue| to an integer by
    truncating its fractional part.
1. If |value|["{{PASignalValue/offset}}"] [=map/exists=], set |returnValue| to
    the result of adding |returnValue| to |value|["{{PASignalValue/offset}}"].
1. Clamp |returnValue| to [=the inclusive range|the range=] 0 to |maxAllowed|,
    inclusive, and return the result.

</div>

<div algorithm>
To <dfn>determine a signal's numeric value</dfn> given a [=signal base value=]
|signalBaseValue| and a <a spec="turtledove">leading bid info</a>
|leadingBidInfo|, perform the following steps. They return a {{double}}.
1. If |signalBaseValue| is "<code>[=signal base value/winning-bid=]</code>":
    1. If |leadingBidInfo|'s <a spec="turtledove" for="leading bid info">leading
        bid</a> is null, return 0.
    1. Otherwise, return  |leadingBidInfo|'s
        <a spec="turtledove" for="leading bid info">leading bid</a>'s
        <a spec="turtledove" for="generated bid">bid</a>.
1. If |signalBaseValue| is
    "<code>[=signal base value/highest-scoring-other-bid=]</code>":
    1. If |leadingBidInfo|'s <a spec="turtledove" for="leading bid info">highest
        scoring other bid</a> is null, return 0.
    1. Otherwise, return |leadingBidInfo|'s
        <a spec="turtledove" for="leading bid info">highest scoring other
        bid</a>'s <a spec="turtledove" for="generated bid">bid</a>.
1. If |signalBaseValue| is "<code>[=signal base value/script-run-time=]</code>":
    1. Return the number of milliseconds of CPU time that the calling function
        (e.g. `generateBid()`) took to run.
1. If |signalBaseValue| is
    "<code>[=signal base value/signals-fetch-time=]</code>":
    Switch on the associated [=worklet function=]:
    <dl class="switch">
    : <code>[=worklet function/generate-bid=]</code>
    :: Return the number of milliseconds it took for the trusted bidding signals
        fetch to complete, or 0 if no fetch was made.
    : <code>[=worklet function/score-ad=]</code>
    :: Return the number of milliseconds it took for the trusted scoring signals
        fetch to complete or 0 if no fetch was made.
    : <code>[=worklet function/report-result=]</code>
    : <code>[=worklet function/report-win=]</code>
    :: Return 0.

    </dl>

    Issue: Consider disallowing this in the latter two [=worklet functions=].
1. If |signalBaseValue| is
    "<code>[=signal base value/bid-reject-reason=]</code>":
    1. If the bid did not succeed purely because it didn't meet the required
        <a spec="turtledove">k-anonymity threshold</a>, return 8.
    1. Let |bidRejectReason| be "`not-available`".
    1. If the seller provided a reject reason, set |bidRejectReason| to that
        value.
    1. If |bidRejectReason| is:
        <dl class="switch">
        : "`not-available`"
        :: Return 0.
        : "`invalid-bid`"
        :: Return 1.
        : "`bid-below-auction-floor`"
        :: Return 2.
        : "`pending-approval-by-exchange`"
        :: Return 3.
        : "`disapproved-by-exchange`"
        :: Return 4.
        : "`blocked-by-publisher`"
        :: Return 5.
        : "`language-exclusions`"
        :: Return 6.
        : "`category-exclusions`"
        :: Return 7.
        : None of the above values
        :: [=Assert=]: false

            Note: this enum value is validated in `scoreAd()`.

            Issue: Verify this once
                    <a href="https://github.com/WICG/turtledove/issues/627">
                    protected-audience/627</a> is resolved.

            Issue: Once <a
                href="https://github.com/WICG/turtledove/pull/594">protected-audience/594</a>
                lands, update this mapping to align.

            Issue: Verify handling when the bid was not rejected.

        </dl>

        Issue: Consider disallowing this from reportWin() and reportResult().

</div>

<div algorithm>
To <dfn>maybe obtain an interest group</dfn> given an
{{InterestGroupScriptRunnerGlobalScope}} |global|, perform the following steps.
They return an [=interest group=] or null:
1. Switch on |global|'s type:
    <dl class="switch">
    : {{InterestGroupBiddingScriptRunnerGlobalScope}}
    :: Return |global|'s <a spec="turtledove"
        for="InterestGroupBiddingScriptRunnerGlobalScope">interest group</a>.
    : {{InterestGroupScoringScriptRunnerGlobalScope}}
    :: Return null.
    : {{InterestGroupReportingScriptRunnerGlobalScope}}
    :: Return |global|'s [=InterestGroupReportingScriptRunnerGlobalScope/interest
        group=].

    </dl>

</div>

<div algorithm>
To <dfn>obtain the Private Aggregation coordinator</dfn> given a
{{ProtectedAudiencePrivateAggregationConfig}} |config|, perform the following
steps. They return an [=aggregation coordinator=], null or a {{DOMException}}.

1. If |config|["{{ProtectedAudiencePrivateAggregationConfig/aggregationCoordinatorOrigin}}"]
    does not [=map/exist=], return null.
1. Return the result of [=obtain the Private Aggregation coordinator from a
    string|obtaining the Private Aggregation coordinator=] given
    |config|["{{ProtectedAudiencePrivateAggregationConfig/aggregationCoordinatorOrigin}}"].

</div>

<div algorithm>
To <dfn lt="obtain the Private Aggregation coordinator from a string">obtain the
Private Aggregation coordinator</dfn> given a {{USVString}} |originString|,
perform the following steps. They return an [=aggregation coordinator=] or a
{{DOMException}}.

1. Let |url| be the result of running the [=URL parser=] on |originString|.
1. If |url| is failure or null, return a new {{DOMException}} with name
    "`SyntaxError`".

    Issue: Consider throwing an error if the path is not empty.
1. Let |origin| be |url|'s [=url/origin=].
1. If the result of [=determining if an origin is an aggregation coordinator=]
    given |origin| is false, return a new {{DOMException}} with name
    "`DataError`".
1. Return |origin|.

</div>

Privacy considerations {#privacy-considerations}
================================================

<em>This section is non-normative.</em>

Cross-site information disclosure {#cross-site-information-disclosure}
----------------------------------------------------------------------

This API lets isolated contexts with access to cross-site data (i.e. <a
href="https://wicg.github.io/shared-storage/">Shared Storage</a> worklets/<a
href="https://wicg.github.io/turtledove/">Protected Audience</a> script runners)
send aggregatable reports over the network.

Aggregatable reports contain encrypted high entropy cross-site information, in
the form of key-value pairs (i.e. contributions to a histogram). The information
embedded in the contributions is arbitrary but can include things like browsing
history and other cross-site activity. The API aims to protect this information
from being passed from one site to another.

### Restricted contribution processing ### {#restricted-contribution-processing}

The histogram contributions are not exposed directly. Instead, they are
encrypted so that they can only be processed by a trusted aggregation service.
This trusted aggregation service sums the values across the reports for each key
and adds noise to each of these values to produce ‘summary reports’.

The output of that processing will be an aggregated, noised histogram. The
service ensures that any report can not be processed multiple times. Further,
information exposure is limited by contribution budgets on the user agent. In
principle, this framework can support specifying a noise parameter which
satisfies differential privacy.

### Unencrypted metadata ### {#unencrypted-metadata}

These reports also expose a limited amount of metadata, which is not based on
cross-site data. The recipient of the report may also be able to observe
side-channel information such as the time when the report was sent, or IP
address of the sender.

### Protecting against leaks via the number of reports ### {#protecting-against-leaks-via-the-number-of-reports}

However, the number of reports with the given metadata could expose some
cross-site information. To protect against this, the API delays sending reports
by a randomized amount of time to make it difficult to determine whether a
report was sent or not from any particular event. In the case that a
[=aggregatable report/context ID=] is supplied or a non-default [=aggregatable
report/filtering ID max bytes=] is specified, the API makes the number of
reports sent deterministic (sending 'null reports' if necessary -- each
containing only a contribution with a value of 0 in the payload). Additional
mitigations may also be possible in the future, e.g. adding noise to the report
count.

### Protecting against leaks via payload size ### {#protecting-against-leaks-via-payload-size}

The length of the payload could additionally expose some cross-site information,
namely how many contributions are included. To protect against this, the payload
is padded to a fixed number of contributions.
### Temporary debugging mechanism ### {#temporary-debugging-mechanism}

The {{PrivateAggregation/enableDebugMode()}} method allows for many of the
protections of this API to be bypassed to ease testing and integration.
Specifically, the contents of the payload, i.e. the histogram contributions, are
revealed in the clear when the debug mode is enabled. Optionally, a debug key
can also be set to associate the report with the calling context. In the future,
this mechanism will only be available for callers that are eligible to set
third-party cookies. In that case, the API caller already has the ability to
communicate information cross-site.

Issue(57): Tie {{PrivateAggregation/enableDebugMode()}} to third-party cookie
    eligibility.

### Privacy parameters ### {#privacy-parameters}

The amount of information exposed by this API is a product of the privacy
parameters used (e.g. contribution limits and the noise distribution used in the
aggregation service). While we aim to minimize the amount of information
exposed, we also aim to support a wide range of use cases. The privacy
parameters are left [=implementation-defined=] to allow different and evolving
choices in the tradeoffs between information exposure and utility.

Clearing site data {#clearing-site-data}
----------------------------------------

The [=aggregatable report cache=] as well as any contribution history data
stored for the [=consume budget if permitted=] algorithm contain data about a
user’s web activity. As such, user controls to delete this data are required,
see [clearing storage](#clearing-storage).

On the other hand, the [=contribution cache=], the [=debug scope map=] and the
[=pre-specified report parameters map=] only contain short-lived data tied to
particular [=batching scopes=] and [=debug scopes=], so controls are not
required.

Reporting delay concerns {#reporting-delay-concerns}
----------------------------------------------------

Delaying sending reports after API invocation can enable side-channel leakage in
some situations.

### Cross-network reporting origin leakage ### {#cross-network-reporting-origin-leakage}

A report may be stored while the browser is connected to one network but sent
while the browser is connected to a different network, potentially enabling
cross-network leakage of the reporting origin.

Example: A user runs the browser with a particular browsing profile on their
home network. An aggregatable report with a particular reporting origin is
stored with a report time in the future. After the report time is reached, the
user runs the browser with the same browsing profile on their employer’s
network, at which point the browser sends the report to the reporting origin.
Although the report itself may be sent over HTTPS, the reporting origin may be
visible to the network administrator via DNS or the TLS client hello (which can
be mitigated with ECH). Some reporting origins may be known to operate only or
primarily on sensitive sites, so this could leak information about the user’s
browsing activity to the user’s employer without their knowledge or consent.

Possible mitigations include:

1. Only sending reports with a given reporting origin when the browser has
    already made a request to that origin on the same network: This prevents the
    network administrator from gaining additional information from the Private
    Aggregation API. However, it increases report loss and report delays, which
    reduces the utility of the API for the reporting origin. It might also
    increase the effectiveness of timing attacks, as the origin may be able to
    better link the report with the user’s request that allowed the report to be
    released.
1. Send reports immediately: This reduces the likelihood of a report being
    stored and sent on different networks. However, it increases the likelihood
    that the reporting origin can correlate the original API invocation to the
    report being sent, which weakens the privacy controls of the API, see
    [Protecting against leaks via the number of
    reports](#protecting-against-leaks-via-the-number-of-reports).
1. Use a trusted proxy server to send reports: This effectively moves the
    reporting origin into the report body, so only the proxy server would be
    visible to the network administrator.
1. Require [[RFC8484|DNS over HTTPS]]: This effectively hides the reporting
    origin from the network administrator, but is likely impractical to enforce
    and is itself perhaps circumventable by the network administrator, e.g. by
    monitoring IP addresses instead.

### User-presence tracking ### {#user-presence-tracking}

The browser only tries to send reports while it is running and while it has
internet connectivity (even without an explicit check for connectivity,
naturally the report will fail to be sent if there is none), so receiving or not
receiving a ([=serializing an aggregatable report|serialized=]) [=aggregatable
report=] at the [=aggregatable report/original report time=] leaks information
about the user’s presence. Additionally, because the report request inherently
includes an IP address, this could reveal the user’s IP-derived location to the
reporting origin, including at-home vs. at-work or approximate real-world
geolocation, or reveal patterns in the user’s browsing activity.

Possible mitigations include:

1. Send reports immediately: This effectively eliminates the presence tracking,
    as the original request made to the reporting origin is in close temporal
    proximity to the report request. However, it increases the likelihood that
    the reporting origin can correlate the original API invocation to the report
    being sent, which weakens the privacy controls of the API, see [Protecting
    against leaks via the number of
    reports](#protecting-against-leaks-via-the-number-of-reports).
1. Send reports immediately to a trusted proxy server, which would itself apply
    additional delay: This would effectively hide both the user’s IP address and
    their online-offline presence from the reporting origin.

Security considerations {#security-considerations}
================================================

<em>This section is non-normative.</em>

Same-origin policy {#same-origin-policy}
----------------------------------------

Writes to the [=aggregatable report cache=], [=contribution cache=], [=debug
scope map=] and [=pre-specified report parameters map=] are attributed to the
reporting [=origin=] and the data included in any report with a given reporting
[=origin=] are generated with only data from that [=origin=].

One notable exception is the [=consume budget if permitted=] algorithm which is
[=implementation-defined=] and can consider contribution history from other
[=origins=]. For example, the algorithm could consider all history from a
particular [=site=]. This would be an explicit relaxation of the same-origin
policy as multiple origins would be able to influence the API's behavior. One
particular risk of these kinds of shared limits is the introduction of denial of
service attacks, where a group of origins could collude to intentionally consume
all available budget, causing subsequent origins to be unable to access the API.
This trades off security for privacy, in that the limits are there to reduce the
efficacy of many origins colluding together to violate privacy. However, this
security risk is lessened if the set of origins limited are all [=same site=].
[=User agents=] should consider these tradeoffs when choosing the [=consume
budget if permitted=] algorithm.

Protecting the histogram contributions {#protecting-the-histogram-contributions}
--------------------------------------------------------------------------------

As discussed [above](#restricted-contribution-processing), the processing of
histogram contributions is limited to protect privacy. This limitation relies on
only the trusted aggregation service being able to access the unencrypted
histogram contributions.

To ensure this, this API uses [[RFC9180|HPKE]], a modern encryption
specification. Additionally, each [=user agent=] is encouraged to require
regular key rotation by the aggregation service. This limits the amount of data
encrypted with the same key and thus the amount of vulnerable data in the case
of a key being compromised.

While not specified here, each [=user agent=] is strongly encouraged to consider
the security of any aggregation service design before allowing its public keys
to be returned by [=obtain the public key for encryption=].
